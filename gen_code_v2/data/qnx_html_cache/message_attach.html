
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="message_attach()" /><meta name="abstract" content="Attach a message range" /><meta name="description" content="Attach a message range" /><meta name="indexterms" content="message_attach()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.resmgr/topic/skeleton_RESMGR_layers.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_block.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_create.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_create_channel.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_handler.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_unblock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/message_connect.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/message_detach.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/_msg_info.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pulse_attach.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="message_attach" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>message_attach()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="message_attach">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">message_attach()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>



<div class="body refbody"><p class="shortdesc"><em class="ph i">Attach a message range</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/iofunc.h&gt;
#include &lt;sys/dispatch.h&gt;

int message_attach( dispatch_t * <var class="keyword varname">dpp</var>,
                    message_attr_t * <var class="keyword varname">attr</var>,
                    int <var class="keyword varname">low</var>,
                    int <var class="keyword varname">high</var>,
                    int (* <var class="keyword varname">func</var>) (
                           message_context_t * <var class="keyword varname">ctp</var>,
                           int <var class="keyword varname">type</var>,
                           unsigned <var class="keyword varname">flags</var>,
                           void * <var class="keyword varname">handle</var> ),
                    void * <var class="keyword varname">handle</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">dpp</var></dt>

<dd class="dd">The dispatch handle, as returned by a successful call to
  <a class="xref" href="../d/dispatch_create.html" title="Allocate a dispatch structure and create the channel associated with it"><span class="keyword apiname">dispatch_create()</span></a>.
</dd>




<dt class="dt dlterm"><var class="keyword varname">attr</var></dt>

<dd class="dd">A pointer to a
  <a class="xref" href="#message_attach__message_attr_t"><span class="keyword dtype">message_attr_t</span> structure</a>
  structure (see below) that lets you specify the attributes for the message,
  or <span class="keyword const">NULL</span> to use the default attributes.
</dd>




<dt class="dt dlterm"><var class="keyword varname">low</var>, <var class="keyword varname">high</var></dt>

<dd class="dd">The range of messages that you're interested in.

  <div class="note note"><span class="notetitle">Note:</span> 
  Although these arguments are of type <span class="keyword dtype">int</span>,
  <span class="keyword apiname">message_attach()</span> stores the values internally as
  <span class="keyword dtype">short</span>; out-of-range values are truncated without warning.
  </div>

</dd>




<dt class="dt dlterm"><var class="keyword varname">func</var></dt>

<dd class="dd">The function that you want to call when a message in the given range is received; see
  <span class="q">&#147;<a class="xref" href="#message_attach__Function">Handler function</a>,&#148;</span> below.
</dd>




<dt class="dt dlterm"><var class="keyword varname">handle</var></dt>

<dd class="dd">An arbitrary handle that you want to associate with data for the defined message range.
  This handle is passed to <var class="keyword varname">func</var>.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">



The <span class="keyword apiname">message_attach()</span> function attaches a handler to the message
range defined by the message type
[<var class="keyword varname">low</var>, <var class="keyword varname">high</var>] 
(i.e., an inclusive message range) for dispatch handle <var class="keyword varname">dpp</var>.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
<ul class="ul">
<li class="li">
It's considered a programming error to attach overlapping message or pulse ranges.
Message types should be greater than 
<span class="keyword const">_IO_MAX</span> (defined in <span class="ph filepath">&lt;sys/iomsg.h&gt;</span>).
</li>


<li class="li">Once you've called <span class="keyword apiname">dispatch_context_alloc()</span>, don't call
  <span class="keyword apiname">message_attach()</span> or <span class="keyword apiname">resmgr_attach()</span>
  specifying a larger maximum message size or a larger number of message parts for the same dispatch handle.
  In QNX Neutrino 7.0 or later, these functions indicate an error of <span class="keyword const">EINVAL</span> if this happens.
</li>


</ul>

</div>


<p class="p">
When a message with a type in that range is received,
<a class="xref" href="../d/dispatch_handler.html" title="Handle events received by dispatch_block()"><span class="keyword apiname">dispatch_handler()</span></a>
calls the user-supplied function <var class="keyword varname">func</var>.
You can also use the same function with
<a class="xref" href="../p/pulse_attach.html" title="Attach a handler function to a pulse code"><span class="keyword apiname">pulse_attach()</span></a>.
By examining <var class="keyword varname">ctp-&gt;rcvid</var>, 
<var class="keyword varname">func</var> can determine whether a pulse or message was received.
</p>


<p class="p">
This function is responsible for doing any specific work needed to handle the message
pointed to by <var class="keyword varname">ctp-&gt;msg</var>. 
The <var class="keyword varname">handle</var> passed to the function is the <var class="keyword varname">handle</var> initially
passed to <span class="keyword apiname">message_attach()</span>.
</p>


<p class="p" id="message_attach__message_attr_t"><strong class="ph b"><span class="keyword dtype">message_attr_t</span> structure</strong></p>


<p class="p">

The <var class="keyword varname">attr</var> argument is a pointer to a <span class="keyword dtype">message_attr_t</span> structure:
</p>


<pre class="pre codeblock">
typedef struct _message_attr {
   unsigned                 flags;
   unsigned                 nparts_max;
   size_t                   msg_max_size;
   unsigned                 reserved[5];
} message_attr_t;
</pre>


<p class="p">
You can use this structure to specify:
</p>


<ul class="ul">
<li class="li">the maximum message size to be received (the context allocated
  must be at least big enough to contain a message of that size)
</li>


<li class="li">the maximum number of iovs to reserve in the
  <span class="keyword dtype">message_context_t</span> structure (<var class="keyword varname">attr-&gt;nparts_max</var>)
</li>


<li class="li">various <var class="keyword varname">flags</var>:

  <p class="p">
  Currently, the following <var class="keyword varname">attr-&gt;flags</var> are defined:
  </p>


  <dl class="dl">
  
  <dt class="dt dlterm"><span class="keyword const">MSG_FLAG_CROSS_ENDIAN</span></dt>

  <dd class="dd">Allow the server to receive messages from clients on machines with different native endian formats.
    
    
    
    
    
  </dd>

  

  
  <dt class="dt dlterm"><span class="keyword const">MSG_FLAG_DEFAULT_FUNC</span></dt>

  <dd class="dd">Call this function if no other match is found, in this case, <var class="keyword varname">low</var> and
    <var class="keyword varname">high</var> are ignored.
    This overrides the default behavior of
    <a class="xref" href="../d/dispatch_handler.html" title="Handle events received by dispatch_block()"><span class="keyword apiname">dispatch_handler()</span></a> 
    which is to return
    <a class="xref" href="msgerror.html" title="Unblock a client and set its error code"><span class="keyword apiname">MsgError</span></a>
    (<span class="keyword const">ENOSYS</span>) to the sender when an unknown message is received.
    <div class="note note"><span class="notetitle">Note:</span> Do not register multiple default functions by calling <span class="keyword apiname">message_attach()</span>
        multiple times with <span class="keyword const">MSG_FLAG_DEFAULT_FUNC</span> set.
        If you do this, which function will get called is undefined.</div>

  </dd>

  

  </dl>

</li>


</ul>


<p class="p" id="message_attach__Function"><strong class="ph b">Handler function</strong></p>


<p class="p">
The user-supplied function <var class="keyword varname">func</var>
is called when a message in the defined range is received.
This function is passed the message context <var class="keyword varname">ctp</var>,
in which the message was received, the message type, and the <var class="keyword varname">handle</var>
(the one passed to <span class="keyword apiname">message_attach()</span>).  
Currently, the argument <var class="keyword varname">flags</var> is reserved.
Your function should return 0; other return values are reserved.
</p>

<div class="note note"><span class="notetitle">Note:</span> 
  Unlike I/O function callouts in a resource manager, there is no automatic client handling based on return value. 
  You must explicitly unblock your client with a call to <span class="keyword apiname">MsgReply*()</span> or <span class="keyword apiname">MsgError()</span>.
</div>

<p class="p">
Here's a brief description of the context pointer fields:
</p>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">ctp-&gt;rcvid</var></dt>

<dd class="dd">The receive ID of the message.</dd>




<dt class="dt dlterm"><var class="keyword varname">ctp-&gt;msg</var></dt>

<dd class="dd">A pointer to the message.</dd>




<dt class="dt dlterm"><var class="keyword varname">ctp-&gt;info</var></dt>

<dd class="dd">Data from a
  <a class="xref" href="_msg_info.html" title="Information about a message"><span class="keyword dtype">_msg_info</span></a>
  structure.
</dd>



</dl>


<p class="p">
The <span class="keyword dtype">message_context_t</span> structure is identical to
<a class="xref" href="../r/resmgr_context_t.html" title="Context information that's passed between resource-manager functions"><span class="keyword dtype">resmgr_context_t</span></a>.
</p>


</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
Zero on success, or -1 on failure (<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a> is set).
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
    <li class="li">A message or pulse <var class="keyword varname">type</var> is out of range.</li>


  <li class="li">(QNX Neutrino 7.0 or later) You've already called <span class="keyword apiname">dispatch_context_alloc()</span>,
    and you've now tried to increase the maximum message size or the number of message parts.
  </li>


  <li class="li">(QNX Neutrino 7.1 or later) You've already called <span class="keyword apiname">dispatch_context_alloc()</span> for a dpp
    with <span class="keyword const">DISPATCH_FLAG_NOLOCK</span>, and you've now tried to add more message handlers.
  </li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">ENOMEM</span></dt>

<dd class="dd">Insufficient memory to attach message type.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Examples:</h2>


<p class="p">
In this example, we create a resource manager where
we attach to a private message range and
attach a pulse, which is then used as a timer event:
</p>


<pre class="pre codeblock">
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;

#define THREAD_POOL_PARAM_T     dispatch_context_t
#include &lt;sys/iofunc.h&gt;
#include &lt;sys/dispatch.h&gt;

static resmgr_connect_funcs_t   connect_func;
static resmgr_io_funcs_t        io_func;
static iofunc_attr_t            attr;

int
timer_tick(message_context_t *ctp, int type, 
           unsigned flags, void *handle) {

    union sigval       value = ctp-&gt;msg-&gt;pulse.value;
    /* Do some useful work on every timer firing... */
    printf("received timer event, value %d\n", value.sival_int);
    return 0;
}

int
message_handler(message_context_t *ctp, int type,
                unsigned flags, void *handle ) {
    printf("received private message, type %d\n", type);
    return 0;
}

int
main(int argc, char **argv) {
    thread_pool_attr_t    pool_attr;
    thread_pool_t         *tpp;
    dispatch_t            *dpp;
    resmgr_attr_t         resmgr_attr;
    int                   id;
    int                   timer_id;
    struct sigevent       event;
    struct _itimer        itime;


    if((dpp = dispatch_create()) == NULL) {
        fprintf(stderr, 
                "%s: Unable to allocate dispatch handle.\n",
                argv[0]);
        return EXIT_FAILURE;
    }

    memset(&amp;pool_attr, 0, sizeof pool_attr);
    pool_attr.handle = dpp;
    /* We are doing resmgr and pulse-type attaches */
    pool_attr.context_alloc = dispatch_context_alloc;
    pool_attr.block_func = dispatch_block;
    pool_attr.unblock_func = dispatch_unblock;
    pool_attr.handler_func = dispatch_handler;
    pool_attr.context_free = dispatch_context_free;
    pool_attr.lo_water = 2;
    pool_attr.hi_water = 4;
    pool_attr.increment = 1;
    pool_attr.maximum = 50;

    if((tpp = thread_pool_create(&amp;pool_attr, 
                                 POOL_FLAG_EXIT_SELF)) == NULL) {
        fprintf(stderr,
                "%s: Unable to initialize thread pool.\n",
                argv[0]);
        return EXIT_FAILURE;
    }

    iofunc_func_init(_RESMGR_CONNECT_NFUNCS, &amp;connect_func,
                     _RESMGR_IO_NFUNCS, &amp;io_func);

    /* You should restrict the permissions according to what you want other
       processes and users to be able to do with your resource manager. */

    iofunc_attr_init(&amp;attr, S_IFNAM | 0660, 0, 0);
        
    memset(&amp;resmgr_attr, 0, sizeof resmgr_attr);
    resmgr_attr.nparts_max = 1;
    resmgr_attr.msg_max_size = 2048;

    if((id = resmgr_attach(dpp, &amp;resmgr_attr, "/dev/mynull", 
                 _FTYPE_ANY, 0,
                 &amp;connect_func, &amp;io_func, &amp;attr)) == -1) {
        fprintf(stderr, "%s: Unable to attach name.\n", argv[0]);
        return EXIT_FAILURE;
    }

    /*
     We want to handle our own private messages, of type 
     0x5000 to 0x5fff
    */
    if(message_attach(dpp, NULL, 0x5000, 0x5fff, 
                      &amp;message_handler, NULL) == -1) {
        fprintf(stderr, 
           "Unable to attach to private message range.\n");
        return EXIT_FAILURE;
    }

    /* Initialize an event structure and attach a pulse to it */
    if((event.sigev_code = pulse_attach(dpp, 
                              MSG_FLAG_ALLOC_PULSE, 0,
                              &amp;timer_tick, NULL)) == -1) {
        fprintf(stderr, "Unable to attach timer pulse.\n");
        return EXIT_FAILURE;
    }

    /* Connect to our channel */
    if((event.sigev_coid = message_connect(dpp, 
                              MSG_FLAG_SIDE_CHANNEL)) == -1) {
        fprintf(stderr, "Unable to attach to channel.\n");
        return EXIT_FAILURE;
    }

    event.sigev_notify = SIGEV_PULSE;
    event.sigev_priority = -1;
    /*
     We could create several timers and use different 
     sigev values for each
    */
    event.sigev_value.sival_int = 0;

    if((timer_id = TimerCreate(CLOCK_MONOTONIC, &amp;event)) == -1) {;
        fprintf(stderr, 
                "Unable to attach channel and connection.\n");
        return EXIT_FAILURE;
    }

    /* And now set up our timer to fire every second */
    itime.nsec = 1000000000;
    itime.interval_nsec = 1000000000;
    TimerSettime(timer_id, 0, &amp;itime, NULL);

    /* Never returns */
    thread_pool_start(tpp);
    return EXIT_SUCCESS;
}
</pre>


<p class="p">
For more examples using the dispatch interface, see
<a class="xref" href="../d/dispatch_create.html" title="Allocate a dispatch structure and create the channel associated with it"><span class="keyword apiname">dispatch_create()</span></a>,
<a class="xref" href="../r/resmgr_attach.html" title="Attach a path to the pathname space"><span class="keyword apiname">resmgr_attach()</span></a>, and
<a class="xref" href="../t/thread_pool_create.html" title="Create a thread pool handle"><span class="keyword apiname">thread_pool_create()</span></a>.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2190202e659">Safety:</th>
<th class="entry" valign="top" id="d2190202e661">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Signal handler</td>
<td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Thread</td>
<td class="entry" valign="top" headers="d2190202e659 d2190202e661 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.resmgr/topic/skeleton_RESMGR_layers.html" title="Layers in a resource manager (Writing a Resource Manager)">Layers in a resource manager (Writing a Resource Manager)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_block.html" title="Block while waiting for an event">dispatch_block()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_create.html" title="Allocate a dispatch structure and create the channel associated with it">dispatch_create()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_create_channel.html" title="Allocate a dispatch structure, specifying a channel ID">dispatch_create_channel()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_handler.html" title="Handle events received by dispatch_block()">dispatch_handler()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/d/dispatch_unblock.html" title="Unblock a thread that is blocked on a dispatch handle">dispatch_unblock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/message_connect.html" title="Create a connection to a channel">message_connect()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/message_detach.html" title="Detach a message range">message_detach()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/_msg_info.html" title="Information about a message">_msg_info</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pulse_attach.html" title="Attach a handler function to a pulse code">pulse_attach()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>