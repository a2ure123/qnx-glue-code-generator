
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="MsgKeyData(), MsgKeyData_r()" /><meta name="abstract" content="Pass data through a common client" /><meta name="description" content="Pass data through a common client" /><meta name="indexterms" content="MsgKeyData(), MsgKeyData_r()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/c/chroot.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/o/open.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/r/rand.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.utilities/topic/r/random.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="msgkeydata" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>MsgKeyData(), MsgKeyData_r()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="msgkeydata">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">MsgKeyData()</span>, <span class="keyword apiname">MsgKeyData_r()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Pass data through a common client</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/neutrino.h&gt;

int MsgKeyData( int <var class="keyword varname">rcvid</var>,
                int <var class="keyword varname">op</var>,
                uint32_t <var class="keyword varname">key</var>,
                uint32_t * <var class="keyword varname">key2</var>,
                const iov_t * <var class="keyword varname">msg</var>,
                int <var class="keyword varname">parts</var> );

int MsgKeyData_r( int <var class="keyword varname">rcvid</var>,
                  int <var class="keyword varname">op</var>,
                  uint32_t <var class="keyword varname">key</var>,
                  uint32_t * <var class="keyword varname">key2</var>,
                  const iov_t * <var class="keyword varname">msg</var>,
                  int <var class="keyword varname">parts</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">rcvid</var></dt>

<dd class="dd">The return value from <span class="keyword apiname">MsgReceive*()</span>.</dd>




<dt class="dt dlterm"><var class="keyword varname">op</var></dt>

<dd class="dd">The operation to perform; one of:

  <ul class="ul">
  <li class="li"><span class="keyword const">_NTO_KEYDATA_CALCULATE</span> â calculate a new key.
    
  </li>


  <li class="li"><span class="keyword const">_NTO_KEYDATA_CALCULATE_REUSE</span> â reuse a key that was previously generated by the kernel.
    
  </li>


  <li class="li"><span class="keyword const">_NTO_KEYDATA_PATHSIGN*</span> â used internally.
    
  </li>


  <li class="li"><span class="keyword const">_NTO_KEYDATA_VERIFY</span> â verify the key.
    
  </li>


  </ul>


  
</dd>




<dt class="dt dlterm"><var class="keyword varname">key</var></dt>

<dd class="dd">A private value for key.
  The value that you use depends on your system's security requirements.
  If security is important, you should use a value read from <span class="ph filepath">/dev/random</span> (see the entry for
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/r/random.html"><span class="keyword cmdname">random</span></a>
  in the <cite class="cite">Utilities Reference</cite>);
  otherwise you might choose to use a statistically random number returned by 
  <a class="xref" href="../r/rand.html" title="Generate a pseudo-random integer"><span class="keyword apiname">rand()</span></a>.

  <p class="p">
  If <var class="keyword varname">op</var> is <span class="keyword const">_NTO_KEYDATA_CALCULATE</span>, you can pass 0 for <var class="keyword varname">key</var>
  to request that the kernel generate a pseudo-random number to use for the key.
  </p>

</dd>




<dt class="dt dlterm"><var class="keyword varname">key2</var></dt>

<dd class="dd">A pointer to a key.
  What the function stores in this location depends on the <var class="keyword varname">op</var>
  argument:

  <ul class="ul">
  <li class="li"><span class="keyword const">_NTO_KEYDATA_CALCULATE</span> â the new key.</li>

  <li class="li"><span class="keyword const">_NTO_KEYDATA_CALCULATE_REUSE</span> â the previously generated key.</li>

  <li class="li"><span class="keyword const">_NTO_KEYDATA_VERIFY</span> â zero if no tampering has
    occurred.
  </li>

  </ul>


</dd>




<dt class="dt dlterm"><var class="keyword varname">msg</var></dt>

<dd class="dd">A pointer to a portion of the reply data to be keyed.</dd>




<dt class="dt dlterm"><var class="keyword varname">parts</var></dt>

<dd class="dd">The number of parts in <var class="keyword varname">msg</var>.
  This number must not exceed 524288, or the function will fail with <span class="keyword const">EINVAL</span>.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">




The <span class="keyword apiname">MsgKeyData()</span> and <span class="keyword apiname">MsgKeyData_r()</span>
kernel calls allow two privileged processes to pass data through a common client while
verifying that the client hasn't modified the data. This is best
explained by an example.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
In order to successfully call these functions, your process must have the
<span class="keyword const">PROCMGR_AID_KEYDATA</span> ability enabled.
For more information, see
<a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.
In QNX Neutrino 7.1 or later, you don't need this ability if the operation is <span class="keyword const">_NTO_KEYDATA_VERIFY</span>.

</div>


<p class="p">
These functions are identical except in the way they indicate errors.
See the <a class="xref" href="#msgkeydata__Returns">Returns</a> section for details.
</p>


<p class="p">
A program calls <a class="xref" href="../o/open.html" title="Open a file"><span class="keyword apiname">open()</span></a> with a
filename. The <span class="keyword apiname">open()</span> function sends a message to the
Process Manager, which is responsible for pathname management.
</p>


<div class="fig fignone">

<img class="image" src="../../images/msgkey1.png" />
<span class="figcap">Figure 1. <span class="keyword apiname">MsgSendv()</span>, client to process manager.</span></div>


<p class="p">
The Process Manager resolves the pathname, 
resulting in a fully qualified network path and the process ID to send the
<span class="keyword apiname">open()</span> request to. This information is replied to the
client.
</p>


<div class="fig fignone">

<img class="image" src="../../images/msgkey2.png" />
<span class="figcap">Figure 2. <span class="keyword apiname">MsgReplyv()</span>, process manager to client.</span></div>


<p class="p">
The client now sends this message to <var class="keyword varname">pid</var> with the
fully qualified pathname.
</p>


<div class="fig fignone">

<img class="image" src="../../images/msgkey3.png" />
<span class="figcap">Figure 3. <span class="keyword apiname">MsgSendv()</span>, client to filesystem manager</span></div>


<p class="p">
Note that the client can change the pathname before it
sends it to the Filesystem Manager.
In fact, it could skip the call to the
Process Manager and manufacture any pathname it desired. The Filesystem
Manager always performs permission checking. Therefore, changing or
manufacturing pathnames isn't normally something to be concerned about, except in one case: 
<a class="xref" href="../c/chroot.html" title="Change the root directory"><span class="keyword apiname">chroot()</span></a>
lets you specify a prefix that must be applied to all pathnames.
</p>


<p class="p">
In the above example, the client may have had a
<span class="keyword apiname">chroot()</span> of <span class="ph filepath">/net/node2/home/dan</span>.
This should limit the process from accessing files outside of
<span class="ph filepath">/net/node2/home/dan</span>. For example:
</p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">

<thead class="thead" align="left">
<tr>
  <th class="entry" valign="top" id="d2235856e430">User path</th>

  <th class="entry" valign="top" id="d2235856e433">Mapped to <span class="keyword apiname">chroot()</span> path</th>

</tr>

</thead>


<tbody class="tbody">

<tr>
  <td class="entry" valign="top" headers="d2235856e430 d2235856e433 "><span class="ph filepath">/bin/ls</span></td>

  <td class="entry" valign="top" headers="d2235856e430 d2235856e433 "><span class="ph filepath">/net/node2/home/dan/bin/ls</span></td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d2235856e430 d2235856e433 "><span class="ph filepath">/</span></td>

  <td class="entry" valign="top" headers="d2235856e430 d2235856e433 "><span class="ph filepath">/net/node2/home/dan</span></td>

</tr>


</tbody>

</table>
</div>


<p class="p">
The process has had its root set to a subdirectory, limiting the
files it can access. For this to work, it's necessary to prevent the
client from changing or manufacturing its own pathnames.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
In the <span class="keyword">QNX Neutrino RTOS</span>, only the Process Manager handles a user 
<a class="xref" href="../c/chroot.html" title="Change the root directory"><span class="keyword apiname">chroot()</span></a>.
Unlike a monolithic kernel where the filesystem shares the same address space 
as the kernel and the <span class="keyword apiname">chroot()</span> information, 
<span class="keyword">QNX Neutrino</span> I/O managers reside in separate address spaces 
and might not even reside on the same machine.
</div>


<p class="p">
The solution to this problem is the <span class="keyword apiname">MsgKeyData()</span> call. 
When the Process Manager receives the 
<a class="xref" href="../o/open.html" title="Open a file"><span class="keyword apiname">open()</span></a>
message, it generates the reply data. 
Before replying, it calls <span class="keyword apiname">MsgKeyData()</span>, with these arguments:
</p>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">rcvid</var></dt>

<dd class="dd">The return value from <span class="keyword apiname">MsgReceive*()</span>.</dd>




<dt class="dt dlterm"><var class="keyword varname">op</var></dt>

<dd class="dd"><span class="keyword const">_NTO_KEYDATA_CALCULATE</span>
    
</dd>




<dt class="dt dlterm"><var class="keyword varname">key</var></dt>

<dd class="dd">A private value for the key.</dd>




<dt class="dt dlterm"><var class="keyword varname">key2</var></dt>

<dd class="dd">A pointer to a new key that should be returned to the client in a unkeyed area of the message.</dd>




<dt class="dt dlterm"><var class="keyword varname">msg</var></dt>

<dd class="dd">A pointer to a portion of the reply data to be keyed.</dd>




<dt class="dt dlterm"><var class="keyword varname">parts</var></dt>

<dd class="dd">The number of parts in <var class="keyword varname">msg</var>.</dd>



</dl>


<p class="p">
The client now sends the message to the File Manager. 
On receipt of the message, the File Manager calls <span class="keyword apiname">MsgKeyData()</span> with the same arguments as
above, except for:
</p>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">op</var></dt>

<dd class="dd"><span class="keyword const">_NTO_KEYDATA_VERIFY</span>
  
</dd>




<dt class="dt dlterm"><var class="keyword varname">key</var></dt>

<dd class="dd">The key that's provided in the message.</dd>



</dl>


<p class="p">
<span class="keyword apiname">MsgKeyData()</span> sets the key pointed to by <var class="keyword varname">key2</var> to zero
if no tampering has occurred.
</p>


<p class="p">
Note that there are actually two keys involved. A public key that's
returned to the client and a private key that the Process Manager generated. 
The algorithm uses both keys and the data for verification.
</p>


<p class="p"><strong class="ph b">Blocking states</strong></p>




<p class="p">
These calls don't block. 
</p>

</div>



<div class="section" id="msgkeydata__Returns"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
The only difference between these functions is the way they indicate errors:
</p>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword apiname">MsgKeyData()</span></dt>

<dd class="dd">If an error occurs, this function returns -1 and sets
  <a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>. Any other value returned
  indicates success.
</dd>




<dt class="dt dlterm"><span class="keyword apiname">MsgKeyData_r()</span></dt>

<dd class="dd">If successful, this function returns <span class="keyword const">EOK</span>. This function does <strong class="ph b">NOT</strong> set <var class="keyword varname">errno</var>, even on success.
    If an error occurs, it may return any value from the Errors section.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">The number of IOV parts exceeds 524288, 
  or the <var class="keyword varname">op</var> argument is invalid.
</dd>




<dt class="dt dlterm"><span class="keyword const">EPERM</span></dt>

<dd class="dd">The calling process doesn't have the required permission; see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.
</dd>




<dt class="dt dlterm"><span class="keyword const">ESRCH</span></dt>

<dd class="dd">The thread indicated by <var class="keyword varname">rcvid</var> doesn't exist.</dd>




<dt class="dt dlterm"><span class="keyword const">EFAULT</span></dt>

<dd class="dd">A fault occurred when the kernel tried to access the buffers provided.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Examples:</h2>


<pre class="pre codeblock">
/*
 * This program demonstrates the use of MsgKeyData() as a way
 * of a client handing off data from a source server to a 
 * destination server such that if the client tampers with 
 * the data, the destination server will know about it.
 */

#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/neutrino.h&gt;

typedef struct {
    int     public_key;
    char    text[10];
} IPC_t;

int chid_src, chid_dst;

void* server_src_thread(void* parm);
void* server_dst_thread(void* parm);

main()
{
    pthread_t   tid[2];
    IPC_t       msg;
    int         coid;
    int         status;

    pthread_create(&amp;tid[0], NULL, server_src_thread, NULL);
    pthread_create(&amp;tid[1], NULL, server_dst_thread, NULL);
    sleep(3); 
    /* give time for channels to be created, sloppy but simple */

    /*
     * Send to server_src_thread for some data.  
     * The data will include some text and a public 
     * key for that text.
     */

    coid = ConnectAttach(0, 0, chid_src, 0, 0);
    MsgSend(coid, NULL, 0, &amp;msg, sizeof(msg));
    ConnectDetach(coid);

    /*
     * Now send to server_dst_thread with the reply from 
     * server_src_thread. We didn't modify the 'text' so it
     * should reply success.  Note that we're including the 
     * public key.
     */

    coid = ConnectAttach(0, 0, chid_dst, 0, 0);
    status = MsgSend(coid, &amp;msg, sizeof(msg), &amp;msg, sizeof(msg));
    printf("Sent unmodified text to server_dst_thread.  
            Replied with %s\n", status == EOK ? "EOK" : "EINVAL" );

    /*
     * Now tamper with the original 'text' (which we aren't 
     * supposed to do) and send to server_dst_thread again 
     * but with the modified 'text' and the public key.  
     * Since we tampered with the 'text', server_dst_thread 
     * should reply failure. 
     */

    strcpy(msg.text, "NEWDATA");
    status = MsgSend(coid, &amp;msg, sizeof(msg), &amp;msg, sizeof(msg));
    printf("Sent modified text to server_dst_thread.  
            Replied with %s\n", status == EOK ? "EOK" : "EINVAL" );

    return 0;
}

void* server_src_thread(void* parm)
{
    int             rcvid;
    int             private_key;  /* the kernel keeps this */
    iov_t           keyed_area_iov;
    IPC_t           msg;
    struct timespec t;

    chid_src = ChannelCreate(0);
    while (1) {
        rcvid = MsgReceive(chid_src, &amp;msg, sizeof(msg), NULL);

        /*
         * Give MsgKeyData() the private key and it will 
         * calculate a public key for the 'text' member of 
         * the message.  The kernel will keep the private key 
         * and we reply with the public key. 
         * Note that we use the number of nanoseconds since the 
         * last second as a way of getting a 32-bit pseudo  
         * random number for the private key.
         */

        clock_gettime(CLOCK_REALTIME, &amp;t);
        private_key = t.tv_nsec; /* nanoseconds since last second */
        strcpy(msg.text, "OKDATA");
        SETIOV(&amp;keyed_area_iov, &amp;msg.text, sizeof(msg.text));
        MsgKeyData(rcvid, _NTO_KEYDATA_CALCULATE, private_key, 
                   &amp;msg.public_key, &amp;keyed_area_iov, 1);

        MsgReply(rcvid, 0, &amp;msg, sizeof(msg));
    }
    return NULL;
}

void* server_dst_thread(void* parm)
{
    int     rcvid, tampered, status;
    iov_t   keyed_area_iov;
    IPC_t   msg;

    chid_dst = ChannelCreate(0);
    while (1) {
        rcvid = MsgReceive(chid_dst, &amp;msg, sizeof(msg), NULL);

        /*
         * Use the public key to see if the data 
         * has been tampered with.
         */

        SETIOV(&amp;keyed_area_iov, &amp;msg.text, sizeof(msg.text));
        MsgKeyData(rcvid, _NTO_KEYDATA_VERIFY, msg.public_key, 
                   &amp;tampered, &amp;keyed_area_iov, 1);

        if (tampered)
            status = EINVAL; /* reply: 'text' was modified */
        else
            status = EOK;    /* reply: 'text' was okay */
        MsgReply(rcvid, status, &amp;msg, sizeof(msg));
    }
    return NULL;
}
</pre>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2235856e783">Safety:</th>
<th class="entry" valign="top" id="d2235856e785">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Signal handler</td>
<td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Thread</td>
<td class="entry" valign="top" headers="d2235856e783 d2235856e785 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/c/chroot.html" title="Change the root directory">chroot()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" title="Wait for a message or pulse on a channel">MsgReceive(), MsgReceive_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" title="Wait for a message or pulse on a channel">MsgReceivev(), MsgReceivev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/o/open.html" title="Open a file">open(), open64()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" title="Control a process's ability to perform certain operations">procmgr_ability()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/r/rand.html" title="Generate a pseudo-random integer">rand()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.utilities/topic/r/random.html" title="random (Utilities Reference)">random (Utilities Reference)</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>