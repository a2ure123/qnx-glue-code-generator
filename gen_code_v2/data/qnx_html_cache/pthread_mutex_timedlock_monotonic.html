
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="pthread_mutex_timedlock(), pthread_mutex_timedlock_monotonic()" /><meta name="abstract" content="Lock a mutex, with a time limit" /><meta name="description" content="Lock a mutex, with a time limit" /><meta name="indexterms" content="pthread_mutex_timedlock(), pthread_mutex_timedlock_monotonic()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_clocklock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_destroy.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_trylock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/syncmutexevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/t/timespec.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="pthread_mutex_timedlock" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>pthread_mutex_timedlock(), pthread_mutex_timedlock_monotonic()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="pthread_mutex_timedlock">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P">P</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">P</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">pthread_mutex_timedlock()</span>, <span class="keyword apiname">pthread_mutex_timedlock_monotonic()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>





<div class="body refbody"><p class="shortdesc"><em class="ph i">Lock a mutex, with a time limit</em></p>


<div class="section">
<p class="p">




</p>

</div>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int pthread_mutex_timedlock( 
                  pthread_mutex_t * <var class="keyword varname">mutex</var>,
                  const struct timespec * <var class="keyword varname">abs_timeout</var> );

int pthread_mutex_timedlock_monotonic( 
                  pthread_mutex_t * <var class="keyword varname">mutex</var>,
                  const struct timespec * <var class="keyword varname">abs_timeout</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">mutex</var></dt>

<dd class="dd">The mutex that you want to lock.</dd>




<dt class="dt dlterm"><var class="keyword varname">abs_timeout</var></dt>

<dd class="dd">A pointer to a
  <a class="xref" href="../t/timespec.html" title="Time-specification structure"><span class="keyword dtype">timespec</span></a>
  structure that specifies the absolute time at which the timeout is to expire.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">
The <span class="keyword apiname">pthread_mutex_timedlock()</span> function locks the mutex object
referenced by <var class="keyword varname">mutex</var>. If the mutex is already locked, the calling thread blocks
until the mutex becomes available as in the
<a class="xref" href="pthread_mutex_lock.html" title="Lock a mutex"><span class="keyword apiname">pthread_mutex_lock()</span></a>
function.
If the mutex can't be locked without waiting for another thread to unlock the mutex,
the wait is terminated when the specified timeout expires.
</p>


<p class="p">

The <span class="keyword apiname">pthread_mutex_timedlock_monotonic()</span> function is a <span class="keyword">QNX Neutrino</span>
extension; it's similar to <span class="keyword apiname">pthread_mutex_timedlock()</span>, but it uses
<span class="keyword const">CLOCK_MONOTONIC</span>, so the timeout isn't affected by changes to the system time.
</p>


<p class="p">
If you want to choose the clock against which the timeout is measured, you can 
instead use <a class="xref" href="pthread_mutex_clocklock.html" title="Lock a mutex with a time limit measured against a specific clock"><span class="keyword apiname">pthread_mutex_clocklock()</span></a>, 
which is similar to <span class="keyword apiname">pthread_mutex_timedlock()</span> and <span class="keyword apiname">pthread_mutex_timedlock_monotonic()</span> 
and differs only because of its clock parameter (<var class="keyword varname">clk</var>). Choosing the clock prevents the 
timeout from being affected by changes to the system time.
</p>


<p class="p">



By default, if a thread with a higher priority than the mutex owner
attempts to lock a mutex, then the effective priority of the current owner is increased to that of the
higher-priority blocked thread waiting for the mutex.
The owner returns to its real priority when it unlocks the mutex.
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html">Mutexes: mutual exclusion locks</a>&#148;</span>
in the QNX Neutrino Microkernel chapter of the <cite class="cite">System Architecture</cite> guide.
</p>


<p class="p">
The timeout expires when the absolute time specified by <var class="keyword varname">abs_timeout</var> passes,
as measured by the clock on which timeouts are based (i.e., when the value of that clock
equals or exceeds <var class="keyword varname">abs_timeout</var>), or if the absolute time specified by <var class="keyword varname">abs_timeout</var>
has already been passed at the time of the call.
</p>


<p class="p">

The timeout is based on the <span class="keyword const">CLOCK_REALTIME</span> clock.
The <span class="keyword dtype">timespec</span> datatype is defined in the <span class="ph filepath">&lt;time.h&gt;</span> header.
</p>


<p class="p">
If the mutex can be locked immediately, the validity of the <var class="keyword varname">abs_timeout</var> parameter isn't checked,
and the function won't fail with a timeout.
</p>


<p class="p">
As a consequence of the priority inheritance rules (for mutexes initialized with the 
<span class="keyword const">PTHREAD_PRIO_INHERIT</span> protocol), if a timed mutex wait is terminated because its
timeout expires, the priority of the owner of the mutex is adjusted as necessary to
reflect the fact that this thread is no longer among the threads waiting for the mutex.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EOK</span></dt>

<dd class="dd">Success.</dd>




<dt class="dt dlterm"><span class="keyword const">EAGAIN</span></dt>

<dd class="dd">The mutex couldn't be acquired because the maximum number of recursive locks 
  for the mutex has been exceeded.
</dd>




<dt class="dt dlterm"><span class="keyword const">EDEADLK</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The mutex type is <span class="keyword const">PTHREAD_MUTEX_ERRORCHECK</span>, and the current thread already owns the mutex.
    
  </li>


  <li class="li">A deadlock condition was detected.</li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The mutex was created with a protocol attribute of
    <span class="keyword const">PTHREAD_PRIO_PROTECT</span>, and the calling thread's priority
    is higher than the mutex's current priority ceiling.
  </li>


  <li class="li">The process or thread
    would have blocked, and the <var class="keyword varname">abs_timeout</var> parameter specified a
    nanoseconds field value less than zero or greater than or equal to 1000 million.
  </li>


  <li class="li">The value specified by <var class="keyword varname">mutex</var> doesn't refer to an initialized mutex object.</li>


  <li class="li">The mutex has died; see
    <a class="xref" href="../s/syncmutexevent.html" title="Attach an event to a mutex"><span class="keyword apiname">SyncMutexEvent()</span></a>.
  </li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">ENOTRECOVERABLE</span></dt>

<dd class="dd">The mutex is a robust mutex, and the state that it protects isn't recoverable.
  All you can do with the mutex is destroy it by calling
  <a class="xref" href="pthread_mutex_destroy.html" title="Destroy a mutex"><span class="keyword apiname">pthread_mutex_destroy()</span></a>. 
</dd>




<dt class="dt dlterm"><span class="keyword const">EOWNERDEAD</span></dt>

<dd class="dd">The mutex is a robust mutex and the process containing the previous owning thread
  terminated while holding the mutex lock.
  The calling thread acquires the mutex lock; it's up to the new owner to make the state consistent (see
  <a class="xref" href="pthread_mutex_consistent.html" title="Mark as consistent the state that's protected by a mutex"><span class="keyword apiname">pthread_mutex_consistent()</span></a>). 
</dd>




<dt class="dt dlterm"><span class="keyword const">ETIMEDOUT</span></dt>

<dd class="dd">The mutex couldn't be locked before the specified timeout expired.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>


<p class="p">
<span class="keyword apiname">pthread_mutex_timedlock()</span> is
<a class="xref" href="../summary.html#summary__CLASSIFICATION">POSIX 1003.1</a>;
<span class="keyword apiname">pthread_mutex_timedlock_monotonic()</span> is
<a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a>
</p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2421785e440">Safety:</th>
<th class="entry" valign="top" id="d2421785e442">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">Signal handler</td>
<td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">Thread</td>
<td class="entry" valign="top" headers="d2421785e440 d2421785e442 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html" title="Mutexes: mutual exclusion locks (System Architecture)">Mutexes: mutual exclusion locks (System Architecture)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_clocklock.html" title="Lock a mutex with a time limit measured against a specific clock">pthread_mutex_clocklock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_destroy.html" title="Destroy a mutex">pthread_mutex_destroy()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" title="Lock a mutex">pthread_mutex_lock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_trylock.html" title="Attempt to lock a mutex">pthread_mutex_trylock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" title="Unlock a mutex">pthread_mutex_unlock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/syncmutexevent.html" title="Attach an event to a mutex">SyncMutexEvent(), SyncMutexEvent_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/t/timespec.html" title="Time-specification structure">timespec</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">P</span></a></span>  </div>
</body>
</html>