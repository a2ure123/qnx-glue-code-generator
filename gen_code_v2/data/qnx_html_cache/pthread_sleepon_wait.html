
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="pthread_sleepon_wait()" /><meta name="abstract" content="Make a thread sleep while waiting" /><meta name="description" content="Make a thread sleep while waiting" /><meta name="indexterms" content="pthread_sleepon_wait()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_cond_wait.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_broadcast.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_signal.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/sched_setscheduler.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="pthread_sleepon_wait" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>pthread_sleepon_wait()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="pthread_sleepon_wait">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P">P</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">P</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">pthread_sleepon_wait()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Make a thread sleep while waiting</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;pthread.h&gt;

int pthread_sleepon_wait( const volatile void * <var class="keyword varname">addr</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">addr</var></dt>

<dd class="dd">The handle that you want the thread to wait for.
  The value of <var class="keyword varname">addr</var> is typically a data structure that controls a
  resource.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">




The <span class="keyword apiname">pthread_sleepon_wait()</span> function uses a mutex and a condition
variable to sleep on a handle, <var class="keyword varname">addr</var>. 
</p>


<p class="p">
The <span class="keyword apiname">pthread_sleepon*</span> functions
provide a simple, uniform way to wait on a variety of resources in a
multithreaded application. For example, a multithreaded filesystem may
wish to wait on such diverse things as a cache block, a file lock, an
operation complete and many others. For example, to wait on a
resource:
</p>


<pre class="pre codeblock">
pthread_sleepon_lock();

while((ptr = cachelist-&gt;free) == NULL) {
    pthread_sleepon_wait(cachelist);
}
cachelist-&gt;free = ptr-&gt;free;

pthread_sleepon_unlock();
</pre>


<p class="p">
To start an operation and wait for its completion:
</p>


<pre class="pre codeblock">
/* Line up for access to the driver */
pthread_sleepon_lock();
if(driver-&gt;busy) {
    pthread_sleepon_wait(&amp;driver-&gt;busy);
}

/* We now have exclusive use of the driver */
driver-&gt;busy = 1;
driver_start(driver);   /* This should be relatively fast */

/* Wait for something to signal driver complete */
pthread_sleepon_wait(&amp;driver-&gt;complete);
pthread_sleepon_unlock();

/* Get the status/data */
driver_complete(driver);

/* Release control of the driver and signal anyone waiting */
pthread_sleepon_lock();
driver-&gt;busy = 0;
pthread_sleepon_signal(&amp;driver-&gt;busy);
pthread_sleepon_unlock();

pthread_exit(NULL);
</pre>


<p class="p">
Choose carefully when you decide whether to use a <samp class="ph codeph">while</samp> loop:
</p>


<ul class="ul">
<li class="li">If the wait on <var class="keyword varname">addr</var> is woken up using 
  <a class="xref" href="pthread_sleepon_broadcast.html" title="Unblock waiting threads"><span class="keyword apiname">pthread_sleepon_broadcast()</span></a>,
  you must use a <samp class="ph codeph">while</samp> loop.
</li>


<li class="li">If threads are woken up using 
  <a class="xref" href="pthread_sleepon_signal.html" title="Signal a sleeping thread"><span class="keyword apiname">pthread_sleepon_signal()</span></a>,
  you <em class="ph i">may</em> use the <samp class="ph codeph">if</samp> conditional if the design of the
  program guarantees proper synchronization and scheduling among contending threads.  
  This is guaranteed in the above example, assuming that none of the threads attempt to reacquire
  the driver resource (i.e., <span class="keyword apiname">pthread_exit()</span> call).
</li>


</ul>


<p class="p"> 
If you're in doubt, use a <samp class="ph codeph">while</samp> loop, because it guarantees
access to the desired resource.
</p>


<p class="p">
You must call
<a class="xref" href="pthread_sleepon_lock.html" title="Lock the pthread_sleepon* functions"><span class="keyword apiname">pthread_sleepon_lock()</span></a>,
which acquires the controlling mutex for the condition variable and ensures that another
thread won't enter the critical section between the test, block, and use of the resource.
Because <span class="keyword apiname">pthread_sleepon_wait()</span> calls
<a class="xref" href="pthread_cond_wait.html" title="Wait on a condition variable"><span class="keyword apiname">pthread_cond_wait()</span></a>,
it releases the controlling mutex when it blocks.
It reacquires the mutex before waking up.
</p>


<p class="p">
The wakeup is accomplished by another thread's calling
<a class="xref" href="pthread_sleepon_signal.html" title="Signal a sleeping thread"><span class="keyword apiname">pthread_sleepon_signal()</span></a>,
which wakes up a single thread, or
<a class="xref" href="pthread_sleepon_broadcast.html" title="Unblock waiting threads"><span class="keyword apiname">pthread_sleepon_broadcast()</span></a>,
which wakes up all threads blocked on <var class="keyword varname">addr</var>.
For a signal, the OS chooses the thread to wake up
by first considering the priority and then for the highest priority level of the blocked theads,
considering the wait time (i.e., FIFO).
For a broadcast, all affected blocked threads become runnable and are scheduled using the usual scheduling rules,
which means the order in which these threads are unblocked (or woken up) is different than the
order in which they were blocked.
</p>


<p class="p">
A single mutex and one condition variable for each unique
address that's currently being blocked on are used.
The total number of
condition variables is therefore equal to the number of unique
<var class="keyword varname">addr</var>s that have a thread waiting on them. This also means
that the maximum number of condition variables never exceeds the
number of threads.  To accomplish this, condition variables are
dynamically created as needed and placed upon an internal freelist for
reuse when not.
</p>


<p class="p">
You might find the <span class="keyword apiname">pthread_sleepon_*()</span>
functions easier to use and understand than condition variables. They
also resemble the traditional <span class="keyword apiname">sleepon()</span> and
<span class="keyword apiname">wakeup()</span> functions found in Unix kernels. They can be
implemented as follows:
</p>


<pre class="pre codeblock">
int _sleepon(void *addr) {
    int ret;

    if((ret = pthread_sleepon_lock()) == EOK) {
        ret = pthread_sleepon_wait(addr);
        pthread_sleepon_unlock();
    }
    return ret;
}

void _wakeup(void *addr) {
    if(pthread_sleepon_lock() == EOK) {
        pthread_sleepon_broadcast(addr);
        pthread_sleepon_unlock();
    }
}
</pre>


<p class="p">
Note that in most Unix kernels, a thread runs until it blocks, and
thus need not worry about protecting the condition it checks with a
mutex. Likewise, when a Unix <span class="keyword apiname">wakeup()</span> is called, there isn't
an immediate thread switch.  Therefore, you can use only the
above simple routines (<span class="keyword apiname">_wakeup()</span> and <span class="keyword apiname">_sleepon()</span>)
if all your threads run with <span class="keyword const">SCHED_FIFO</span> scheduling and
at the same priority, thus more closely mimicking Unix kernel
scheduling.
</p>


</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EOK</span></dt>

<dd class="dd">Success.</dd>




<dt class="dt dlterm"><span class="keyword const">EDEADLK</span></dt>

<dd class="dd">The calling thread already owns the controlling mutex.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2454635e312">Safety:</th>
<th class="entry" valign="top" id="d2454635e314">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Signal handler</td>
<td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Thread</td>
<td class="entry" valign="top" headers="d2454635e312 d2454635e314 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>





<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" title="Processes and Threads (Getting Started with QNX Neutrino)">Processes and Threads (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_cond_wait.html" title="Wait on a condition variable">pthread_cond_wait()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" title="Lock a mutex">pthread_mutex_lock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" title="Unlock a mutex">pthread_mutex_unlock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_broadcast.html" title="Unblock waiting threads">pthread_sleepon_broadcast()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_lock.html" title="Lock the pthread_sleepon* functions">pthread_sleepon_lock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_signal.html" title="Signal a sleeping thread">pthread_sleepon_signal()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_sleepon_unlock.html" title="Unlock the pthread_sleepon*() functions">pthread_sleepon_unlock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/sched_setscheduler.html" title="Change the priority and scheduling policy of a process">sched_setscheduler()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-p.html" title="P"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">P</span></a></span>  </div>
</body>
</html>