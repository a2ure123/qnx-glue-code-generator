
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="forksafe_mutex_lock()" /><meta name="abstract" content="Lock a forksafe mutex" /><meta name="description" content="Lock a forksafe mutex" /><meta name="indexterms" content="forksafe_mutex_lock()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_destroy.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_init.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_trylock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/fork.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_destroy.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_init.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_trylock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="forksafe_mutex_lock" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>forksafe_mutex_lock()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="forksafe_mutex_lock">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F">F</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">F</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">forksafe_mutex_lock()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Lock a forksafe mutex</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;forksafe_mutex.h&gt;

int forksafe_mutex_lock( forksafe_mutex_t* <var class="keyword varname">mutex</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">


<dt class="dt dlterm"><var class="keyword varname">mutex</var></dt>


<dd class="dd">A pointer to the <span class="keyword dtype">forksafe_mutex_t</span> object that you want to
  lock.

</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span>, <span class="ph filepath">libforksafe_mutex</span></p>


<p class="p">
In QNX Neutrino 7.1 or later, there are two versions of the <span class="keyword apiname">forksafe_mutex_*()</span> functions:
</p>


<ul class="ul">
<li class="li">The functions in <span class="ph filepath">libc</span> are declared as weak symbols and use a regular mutex,
  simply calling the corresponding <span class="keyword apiname">pthread_mutex_*()</span> functions.
  Use the <span class="keyword option">-l c</span> option to
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
  to link against this library.
  This library is usually included automatically.
</li>


<li class="li">The functions in <span class="ph filepath">libforksafe_mutex</span> use a forksafe mutex.
  Use the <span class="keyword option">-l forksafe_mutex</span> option to
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
  to link against this library.
</li>


</ul>


</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">




The <span class="keyword apiname">forksafe_mutex_lock()</span> function locks the forksafe mutex referenced by <var class="keyword varname">mutex</var>. 
If the mutex is already locked, then the calling thread blocks until it has acquired the mutex. 
When the function returns, the mutex object is locked and owned by the
calling thread.
</p>


<p class="p">
This function's behavior when you try to lock a mutex that
you already own depends on the type of the mutex.
For more information, see the entry for
<a class="xref" href="../p/pthread_mutexattr_settype.html" title="Set a mutex type"><span class="keyword apiname">pthread_mutexattr_settype()</span></a>.
</p>


<p class="p">



By default, if a thread with a higher priority than the mutex owner
attempts to lock a mutex, then the effective priority of the
current owner is increased to that of the
higher-priority blocked thread waiting for the mutex. The
owner returns to its real priority when it unlocks the mutex.
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html">Mutexes: mutual exclusion locks</a>&#148;</span>
in the <span class="q">&#147;QNX Neutrino Microkernel&#148;</span> chapter of the
<cite class="cite">System Architecture</cite> guide.
</p>


<p class="p">
If the mutex is recursive, you must call
<a class="xref" href="forksafe_mutex_unlock.html" title="Unlock a forksafe mutex"><span class="keyword apiname">forksafe_mutex_unlock()</span></a>
for each corresponding call to lock the mutex.
</p>


<p class="p">
If a signal is delivered to a thread that's waiting for a mutex, the thread
resumes waiting for the mutex on returning from the signal handler.
</p>


<p class="p">
If, before initializing the mutex, you've called
<a class="xref" href="../p/pthread_mutexattr_setwakeup_np.html" title="Set the wake-up attribute of a mutex"><span class="keyword apiname">pthread_mutexattr_setwakeup_np()</span></a>
to enable wake-ups, you can later call
<a class="xref" href="../p/pthread_mutex_wakeup_np.html" title="Unblock any threads that are waiting on a mutex"><span class="keyword apiname">pthread_mutex_wakeup_np()</span></a>,
to wake up any threads that are blocked on the mutex.
The <span class="q">&#147;np&#148;</span> in this function's name stands for
<span class="q">&#147;non-POSIX.&#148;</span></p>


<p class="p">
For more information about forksafe mutexes, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs_Multithreaded_fork.html">Using <span class="keyword apiname">fork()</span> in a multithreaded process</a>&#148;</span>
in the <span class="q">&#147;Processes and Threads&#148;</span> chapter of <cite class="cite">Getting Started with <span class="keyword">QNX Neutrino</span></cite>.
</p>


</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EOK</span></dt>

<dd class="dd">Success.</dd>




<dt class="dt dlterm"><span class="keyword const">EAGAIN</span></dt>

<dd class="dd">The mutex couldn't be acquired because the maximum number of recursive locks for mutex has been exceeded.</dd>




<dt class="dt dlterm"><span class="keyword const">EDEADLK</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The mutex type is <span class="keyword const">PTHREAD_MUTEX_ERRORCHECK</span>, and the current thread already owns the mutex.
    
  </li>


  <li class="li">A deadlock condition was detected.</li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">EFAULT</span></dt>

<dd class="dd">A fault occurred when the kernel tried to access the buffers you provided.</dd>




<dt class="dt dlterm"><span class="keyword const">EINTR</span></dt>

<dd class="dd">(<span class="keyword">QNX Neutrino</span> extension) The thread was unblocked by a call to
  <a class="xref" href="../p/pthread_mutex_wakeup_np.html" title="Unblock any threads that are waiting on a mutex"><span class="keyword apiname">pthread_mutex_wakeup_np()</span></a>.
</dd>




<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The mutex was created with a protocol attribute of
    <span class="keyword const">PTHREAD_PRIO_PROTECT</span>, and the calling thread's priority
    is higher than the mutex's current priority ceiling.
  </li>


  <li class="li">The mutex is invalid, or it has died (see
    <a class="xref" href="../s/syncmutexevent.html" title="Attach an event to a mutex"><span class="keyword apiname">SyncMutexEvent()</span></a>).
  </li>


  <li class="li">(<span class="keyword">QNX Neutrino</span> extension; QNX Neutrino 7.0.1 or later)
    You're using safe shared mutexes (see the <span class="keyword option">-s</span> option for
    <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/p/procnto.html"><span class="keyword cmdname">procnto</span></a>),
    and you tried to lock a <span class="keyword const">PTHREAD_PRIO_INHERIT</span> mutex
    whose owner isn't known to the kernel and that the locking thread claims is from a different process.
  </li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">ENOTRECOVERABLE</span></dt>

<dd class="dd">The mutex is a robust mutex, and the state that it protects isn't recoverable.
  All you can do with the mutex is destroy it by calling
  <a class="xref" href="forksafe_mutex_destroy.html" title="Destroy a forksafe mutex"><span class="keyword apiname">forksafe_mutex_destroy()</span></a>. 
</dd>




<dt class="dt dlterm"><span class="keyword const">EOWNERDEAD</span></dt>

<dd class="dd">The mutex is a robust mutex, and the process containing the previous owning thread
  terminated while holding the mutex lock.
  The calling thread acquires the mutex lock; it's up to the new owner to make the state consistent (see
  <a class="xref" href="../p/pthread_mutex_consistent.html" title="Mark as consistent the state that's protected by a mutex"><span class="keyword apiname">pthread_mutex_consistent()</span></a>). 
</dd>




<dt class="dt dlterm"><span class="keyword const">ETIMEDOUT</span></dt>

<dd class="dd">A kernel timeout unblocked the call.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Examples:</h2>


<p class="p">
This example shows how you can use a mutex to synchronize access to
a shared variable.  In this example, <span class="keyword apiname">function1()</span> and
<span class="keyword apiname">function2()</span> both attempt to access and modify the
global variable <var class="keyword varname">count</var>.  Either thread could be interrupted
between modifying <var class="keyword varname">count</var> and assigning its value to the
local <var class="keyword varname">tmp</var> variable.  Locking <var class="keyword varname">mutex</var> prevents
this from happening; if one thread has <var class="keyword varname">mutex</var> locked, the
other thread waits until it's unlocked, before continuing.
</p>


<pre class="pre codeblock">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;forksafe_mutex.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

forksafe_mutex_t mutex = FORKSAFE_MUTEX_INITIALIZER;
int count = 0;

void* function1( void* arg )
{
    int tmp = 0, ret_code;
    
    while( 1 ) {
        ret_code = forksafe_mutex_lock( &amp;mutex );
        if (ret_code == EOK)
        {
            tmp = count++;
            ret_code = forksafe_mutex_unlock( &amp;mutex );
            if (ret_code != EOK)
            {
                printf ("forksafe_mutex_unlock() failed: %s\n",
                        strerror(ret_code));
            }
                
            printf ("Count is %d\n", tmp );
        }
        else
        {
            printf ("forksafe_mutex_lock() failed: %s\n",
                    strerror(ret_code));
        }
            
        /* Snooze for 1 second */
        sleep( 1 );
    }
    
    return 0;
}

void* function2( void* arg )
{
    int tmp = 0, ret_code;

    while( 1 ) {
        ret_code = forksafe_mutex_lock( &amp;mutex );
        if (ret_code == EOK)
        {
            tmp = count--;
            ret_code = forksafe_mutex_unlock( &amp;mutex );
            if (ret_code != EOK)
            {
                printf ("** forksafe_mutex_unlock() failed: %s\n",
                        strerror (ret_code));
            }
            printf ("** Count is %d\n", tmp );
        }
        else
        {
            printf ("** forksafe_mutex_lock() failed: %s\n",
                    strerror (ret_code));
        }
            
        /* Snooze for 2 seconds */
        sleep( 2 );
    }

    return 0;
}

int main( void )
{
	int ret_code;
	
    ret_code = pthread_create( NULL, NULL, &amp;function1, NULL );
	if (ret_code != EOK)
	{
		printf ("Couldn't create first thread: %s\n",
				strerror (ret_code));
	}
    ret_code = pthread_create( NULL, NULL, &amp;function2, NULL );
	if (ret_code != EOK)
	{
		printf ("Couldn't create second thread: %s\n",
				strerror (ret_code));
	}
    
    /* Let the threads run for 60 seconds. */
    sleep( 60 );

    return EXIT_SUCCESS;
}
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>




<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d1455403e482">Safety:</th>
<th class="entry" valign="top" id="d1455403e484">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">Cancellation point</td>
<td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">Signal handler</td>
<td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">Thread</td>
<td class="entry" valign="top" headers="d1455403e482 d1455403e484 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.sys_arch/topic/kernel_Mutexes.html" title="Mutexes: mutual exclusion locks (System Architecture)">Mutexes: mutual exclusion locks (System Architecture)</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" title="Processes and Threads (Getting Started with QNX Neutrino)">Processes and Threads (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_destroy.html" title="Destroy a forksafe mutex">forksafe_mutex_destroy()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_init.html" title="Initialize a forksafe mutex">forksafe_mutex_init()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_trylock.html" title="Attempt to lock a forksafe mutex">forksafe_mutex_trylock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_unlock.html" title="Unlock a forksafe mutex">forksafe_mutex_unlock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/fork.html" title="Create a new process">fork()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_destroy.html" title="Destroy a mutex">pthread_mutex_destroy()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_init.html" title="Initialize a mutex">pthread_mutex_init()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_lock.html" title="Lock a mutex">pthread_mutex_lock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_trylock.html" title="Attempt to lock a mutex">pthread_mutex_trylock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_mutex_unlock.html" title="Unlock a mutex">pthread_mutex_unlock()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">F</span></a></span>  </div>
</body>
</html>