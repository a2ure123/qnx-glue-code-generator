
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="MsgWrite(), MsgWrite_r()" /><meta name="abstract" content="Write a reply" /><meta name="description" content="Write a reply" /><meta name="indexterms" content="MsgWrite(), MsgWrite_r()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/c/channelcreate.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgread.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreadv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreply.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreplyv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwritev.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="msgwrite" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>MsgWrite(), MsgWrite_r()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="msgwrite">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">MsgWrite()</span>, <span class="keyword apiname">MsgWrite_r()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Write a reply</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/neutrino.h&gt;

ssize_t MsgWrite( int <var class="keyword varname">rcvid</var>,
                  const void* <var class="keyword varname">msg</var>, 
                  size_t <var class="keyword varname">size</var>,
                  size_t <var class="keyword varname">offset</var> );

ssize_t MsgWrite_r( int <var class="keyword varname">rcvid</var>,
                    const void* <var class="keyword varname">msg</var>, 
                    size_t <var class="keyword varname">size</var>,
                    size_t <var class="keyword varname">offset</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">rcvid</var></dt>

<dd class="dd">The value returned by <span class="keyword apiname">MsgReceive*()</span> when you received the message.</dd>




<dt class="dt dlterm"><var class="keyword varname">msg</var></dt>

<dd class="dd">A pointer to a buffer that contains the data you want to write.</dd>




<dt class="dt dlterm"><var class="keyword varname">size</var></dt>

<dd class="dd">The number of bytes that you want to write.
  This number must not exceed <span class="keyword const">SSIZE_MAX</span>, or the function will behave unpredictably.
  <p class="p">These functions don't let you write past the end of the sender's buffer;
    they return the number of bytes actually written.</p>

</dd>




<dt class="dt dlterm"><var class="keyword varname">offset</var></dt>

<dd class="dd">An offset into the sender's buffer that indicates where you want to start writing the data.</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">



The <span class="keyword apiname">MsgWrite()</span> and <span class="keyword apiname">MsgWrite_r()</span>
kernel calls write data to the
reply buffer of a thread identified by <var class="keyword varname">rcvid</var>.
The thread being written to must be in the
REPLY-blocked state. Any thread in the receiving
process is free to write to the reply message.
</p>


<p class="p">
These functions are identical except in the way they indicate errors.
See the <a class="xref" href="#msgwrite__Returns">Returns</a> section for details.
</p>


<p class="p">
In the local case, the data transfer occurs
immediately and your thread doesn't block (see <span class="q">&#147;Blocking states,&#148;</span> below).
The state of the sending thread doesn't change.
</p>


<p class="p">
You use this function in one of these situations:
</p>


<ul class="ul">
<li class="li">The data arrives over time and is quite large.
  Rather than buffer all the data, you can use <span class="keyword apiname">MsgWrite()</span> to
  write it into the destination thread's reply message buffer, as it arrives.
</li>


<li class="li">Messages are received that are larger than available buffer space.
  Perhaps the process is an agent between two processes and simply filters the data and passes it on.
  You can use <span class="keyword apiname">MsgRead*()</span> to read messages in small pieces,
  and use <span class="keyword apiname">MsgWrite()</span> to write messages in small pieces.
</li>


</ul>


<p class="p">
To complete a message exchange, you must call <span class="keyword apiname">MsgReply*()</span>.
The reply doesn't need to contain any data. If it does
contain data, then the data is always written at offset zero in the
destination thread's reply message buffer.  This is a convenient way of
writing the header once all of the information has been gathered.
</p>


<p class="p">
A single call to <span class="keyword apiname">MsgReply*()</span> is always more
efficient than calls to <span class="keyword apiname">MsgWrite()</span> followed by a
call to <span class="keyword apiname">MsgReply*()</span>.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
As a client may have overlapping send and reply buffers, you must complete all<span class="keyword apiname"> MsgRead*()</span> operations from a particular send (i.e. particular rcvid) before initiating any <span class="keyword apiname">MsgWrite*()</span> operations to that client.
</div>


<p class="p"><strong class="ph b">Blocking states</strong></p>




<p class="p">
None for the local case. In the network case:
</p>


<dl class="dl">

<dt class="dt dlterm" id="msgwrite__state_reply"><span class="keyword const">STATE_REPLY</span></dt>

<dd class="dd">The calling thread is waiting for a network operation to complete.
  The calling thread is marked as REPLY-blocked on itself (the same process ID as the thread making the call).
  
</dd>



</dl>


<p class="p"><strong class="ph b">Native networking</strong></p>


<p class="p">
The <span class="keyword apiname">MsgWrite()</span> function has increased latency when
you use it to communicate across a network because the server is now writing data to its local
<span class="ph filepath">lsm-qnet.so</span>, which
may need to communicate with the client's
<span class="ph filepath">lsm-qnet.so</span> to actually transfer the data. 
The server's <span class="keyword apiname">MsgWrite()</span> call effectively sends a
message to the server's <span class="ph filepath">lsm-qnet.so</span> to initiate this data transfer.
</p>


<p class="p">
But since the server's <span class="ph filepath">lsm-qnet.so</span>
has no way to determine the size of the client's receive
data area, the number of bytes reported as having been
transferred by the server during its <span class="keyword apiname">MsgWrite()</span> call 
<em class="ph i">might not be accurate</em>; the reported number
will instead reflect the number of bytes transferred by the
server to its <span class="ph filepath">lsm-qnet.so</span>.
</p>


<p class="p">
The message is buffered in the server side's <span class="ph filepath">lsm-qnet.so</span>
until the client replies, in order to reduce the number of network
transactions.
</p>




</div>



<div class="section" id="msgwrite__Returns"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
The only difference between <span class="keyword apiname">MsgWrite()</span> and <span class="keyword apiname">MsgWrite_r()</span>
is the way they indicate errors:
</p>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword apiname">MsgWrite()</span></dt>

<dd class="dd">If successful, this function returns the number of bytes written.
If an error occurs, it returns -1 and sets
<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>.
</dd>




<dt class="dt dlterm"><span class="keyword apiname">MsgWrite_r()</span></dt>

<dd class="dd">If successful, this function returns the number of bytes written. 
If an error occurs, it may return the negative of any value from the Errors section.
This function does <strong class="ph b">NOT</strong> set <var class="keyword varname">errno</var>, even on success.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EDEADLK</span></dt>

<dd class="dd">A deadlock occurred.
  You can avoid a deadlock by setting the <span class="keyword const">_NTO_CHF_MSG_PAUSING</span> flag when you create 
  a channel; for more information, see
  <a class="xref" href="../c/channelcreate.html" title="Create a communications channel"><span class="keyword apiname">ChannelCreate()</span></a>
  and
  <a class="xref" href="msgpause.html" title="Pause the processing of a message"><span class="keyword apiname">MsgPause()</span></a>.
</dd>




<dt class="dt dlterm"><span class="keyword const">EFAULT</span></dt>

<dd class="dd">A fault occurred in the sender's address space when the kernel tried to access the
  sender's return message buffer.
</dd>




<dt class="dt dlterm"><span class="keyword const">ESRCH</span></dt>

<dd class="dd">The thread indicated by <var class="keyword varname">rcvid</var> doesn't exist, is
  no longer REPLY-blocked on the channel, or the connection was detached.
</dd>




<dt class="dt dlterm"><span class="keyword const">ESRVRFAULT</span></dt>

<dd class="dd">A fault occurred when the kernel tried to access the buffers provided.</dd>




<dt class="dt dlterm"><span class="keyword const">ETIMEDOUT</span></dt>

<dd class="dd">A kernel timeout unblocked the call. See
  <a class="xref" href="../t/timertimeout.html" title="Set a timeout on a blocking state"><span class="keyword apiname">TimerTimeout()</span></a>.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2261022e464">Safety:</th>
<th class="entry" valign="top" id="d2261022e466">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Signal handler</td>
<td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Thread</td>
<td class="entry" valign="top" headers="d2261022e464 d2261022e466 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" title="Message Passing (Getting Started with QNX Neutrino)">Message Passing (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/c/channelcreate.html" title="Create a communications channel">ChannelCreate(), ChannelCreate_r(), ChannelCreatePulsePool()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgread.html" title="Read data from a message">MsgRead(), MsgRead_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreadv.html" title="Read data from a message">MsgReadv(), MsgReadv_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" title="Wait for a message or pulse on a channel">MsgReceive(), MsgReceive_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" title="Wait for a message or pulse on a channel">MsgReceivev(), MsgReceivev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreply.html" title="Reply with a message">MsgReply(), MsgReply_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreplyv.html" title="Reply with a message">MsgReplyv(), MsgReplyv_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwritev.html" title="Write a reply">MsgWritev(), MsgWritev_r()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>