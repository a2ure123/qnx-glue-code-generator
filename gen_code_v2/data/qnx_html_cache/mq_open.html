
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="mq_open()" /><meta name="abstract" content="Open a message queue" /><meta name="description" content="Open a message queue" /><meta name="indexterms" content="mq_open()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Message_queues.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.technotes/topic/managing_mq_mqueue.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_close.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_getattr.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_notify.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_receive.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_send.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_setattr.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_timedreceive.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_timedsend.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_unlink.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.utilities/topic/m/mqueue.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="mq_open" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>mq_open()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="mq_open">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">mq_open()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Open a message queue</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;mqueue.h&gt;
#include &lt;fcntl.h&gt;

mqd_t mq_open( const char * <var class="keyword varname">name</var>, 
               int <var class="keyword varname">oflag</var>,
               ... )
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">name</var></dt>

<dd class="dd">The name of the message queue that you want to open; see below.</dd>




<dt class="dt dlterm"><var class="keyword varname">oflag</var></dt>

<dd class="dd">You must specify one of <span class="keyword const">O_RDONLY</span> (receive-only),
  <span class="keyword const">O_WRONLY</span> (send-only) or <span class="keyword const">O_RDWR</span> (send-receive).
  In addition, you can OR in the following constants to produce the following effects:
  
  
  
  
  
  
 
  <ul class="ul">
  <li class="li"><span class="keyword const">O_CREAT</span> â if <var class="keyword varname">name</var> doesn't exist,
    instruct the server to create a new message queue with the given name.
    If you specify this flag, <span class="keyword apiname">mq_open()</span> uses its
    <var class="keyword varname">mode</var> and <var class="keyword varname">mq_attr</var> arguments; see below.
    
  </li>


  <li class="li"><span class="keyword const">O_EXCL</span> â if you set both <span class="keyword const">O_EXCL</span> and
    <span class="keyword const">O_CREAT</span>, and a message queue <var class="keyword varname">name</var> exists, the
     call fails and <var class="keyword varname">errno</var> is set to <span class="keyword const">EEXIST</span>.
     Otherwise, the queue is created normally.
     If you set <span class="keyword const">O_EXCL</span> without <span class="keyword const">O_CREAT</span>, it's ignored.
     
  </li>


  <li class="li"><span class="keyword const">O_NONBLOCK</span> â under normal message queue operation,
    a call to <span class="keyword apiname">mq_send()</span> or <span class="keyword apiname">mq_receive()</span> could block
    if the message queue is full or empty.
    If you set this flag, these calls never block.
    If the queue isn't in a condition to perform the given call,
    <var class="keyword varname">errno</var> is set to <span class="keyword const">EAGAIN</span> and the call returns an error.
    
  </li>


  </ul>

</dd>



</dl>


<p class="p">
If you set <span class="keyword const">O_CREAT</span> in the <var class="keyword varname">oflag</var> argument,
you must also pass these arguments to <span class="keyword apiname">mq_open()</span>:
</p>


<dl class="dl">

<dt class="dt dlterm"><span class="keyword dtype">mode_t</span> <var class="keyword varname">mode</var></dt>

<dd class="dd">The file permissions for the new queue.
  For more information, see the entry for
  <a class="xref" href="../s/stat_struct.html" title="Data structure for information about a file or directory"><span class="keyword dtype">struct stat</span></a>.

  <p class="p">
  If you set any bits other than file permission bits, they're ignored.
  Read and write permissions are analogous to receive and send
  permissions; execute permissions are ignored.
  </p>

</dd>




<dt class="dt dlterm"><span class="keyword dtype">struct mq_attr *</span><var class="keyword varname">mq_attr</var></dt>

<dd class="dd"><span class="keyword const">NULL</span>, or a pointer to an <span class="keyword dtype">mq_attr</span>
  structure that contains the attributes that you want to use for the new queue.
  For more information, see
  <a class="xref" href="mq_getattr.html" title="Get a message queue's attributes"><span class="keyword apiname">mq_getattr()</span></a>.

  <p class="p">
  If <var class="keyword varname">mq_attr</var> is <span class="keyword const">NULL</span>, the following default
  attributes are usedâdepending on which implementation of
  message queues you're usingâprovided that you didn't override
  the defaults when you started the message-queue server:
  </p>


  
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">

  <thead class="thead" align="left">
  <tr>
    <th class="entry" valign="top" id="d2223958e249">Attribute</th>

    <th class="entry" valign="top" id="d2223958e252">Traditional</th>

    <th class="entry" valign="top" id="d2223958e255">Alternate</th>

  </tr>

  </thead>


  <tbody class="tbody">
  <tr>
    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 "><var class="keyword varname">mq_maxmsg</var></td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">1024</td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">64</td>

  </tr>


  <tr>
    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 "><var class="keyword varname">mq_msgsize</var></td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">4096</td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">256</td>

  </tr>


  <tr>
    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 "><var class="keyword varname">mq_flags</var></td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">0</td>

    <td class="entry" valign="top" headers="d2223958e249 d2223958e252 d2223958e255 ">0</td>

  </tr>


  </tbody>

  </table>
</div>


  <p class="p">
  If <var class="keyword varname">mq_attr</var> isn't <span class="keyword const">NULL</span>, the new queue 
  adopts the <var class="keyword varname">mq_maxmsg</var> and <var class="keyword varname">mq_msgsize</var> of <span class="keyword dtype">mq_attr</span>.
  The <var class="keyword varname">mq_flags</var> flags field is ignored.
  </p>

</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<ul class="ul">
<li class="li">For the traditional implementation, <span class="ph filepath">libc</span>:

  <p class="p">
  Use the <span class="keyword option">-l c</span> option to
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
  to link against this library.
  This library is usually included automatically.
  </p>

</li>


<li class="li">For the alternate implementation that uses the <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html"><span class="keyword cmdname">mq</span></a>
          server and a queue in kernel space, <span class="ph filepath">libmq</span>: <p class="p"> Use the <span class="keyword option">-l
              mq</span> option to <span class="keyword cmdname">qcc</span> to link against this library. </p>

        </li>


</ul>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">


The <span class="keyword apiname">mq_open()</span> function opens a message queue referred to by <var class="keyword varname">name</var>, 
and returns a message queue descriptor by which the queue can be referenced in the future.
</p>


<div class="note note"><span class="notetitle">Note:</span>  The message queue manager needs to be running. <span class="keyword">QNX Neutrino</span> supports two
        implementations of message queues: a traditional implementation, and an alternate one that
        uses the <span class="keyword cmdname">mq</span> server and a queue in kernel space. For more information, see
        the entries for <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html"><span class="keyword cmdname">mq</span></a> and <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mqueue.html"><span class="keyword cmdname">mqueue</span></a> in the <cite class="cite">Utilities Reference</cite>, as well as the
<a class="xref" href="../../../com.qnx.doc.neutrino.technotes/topic/managing_mq_mqueue.html">POSIX Message Queues: Two Implementations</a>
technote. </div>


<p class="p">
The <span class="keyword apiname">mq_open()</span> function creates an entry for the message queue in the pathname space:
</p>


<ul class="ul">
<li class="li">With the traditional (<span class="keyword cmdname">mqueue</span>) implementation, message queues are created under
  <span class="ph filepath">/dev/mqueue</span>.
</li>


<li class="li">With the alternate (<span class="keyword cmdname">mq</span>) implementation, message queues
  are created under <span class="ph filepath">/dev/mq</span> (or the path specified
  with the <span class="keyword option">-N</span> option to
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html"><span class="keyword cmdname">mq</span></a>).
</li>


</ul>


<p class="p">
The <var class="keyword varname">name</var> argument is interpreted as follows:
</p>


  <ul class="ul">
  <li class="li">If the <var class="keyword varname">name</var> argument starts with a slash, the queue is given that name.</li>


  <li class="li">If the <var class="keyword varname">name</var> argument doesn't begin with a slash character, the queue is given that name,
    prepended with the current working directory.
  </li>


  </ul>


  <p class="p">
  In either case, slash characters other than the leading slash character
  aren't interpreted, and the specified name, including these slash
  characters, is used to identify the message queue.
  In other words, additional slashes don't create a directory structure under
  <span class="ph filepath">/dev/mqueue</span> or <span class="ph filepath">/dev/mq</span>.
  </p>


  <p class="p">
  For example, if your current directory is <span class="ph filepath">/tmp</span>:
  </p>


  
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">

  <thead class="thead" align="left">
  <tr>
    <th class="entry" valign="top" id="d2223958e506"><var class="keyword varname">name</var></th>

    <th class="entry" valign="top" id="d2223958e510">Entry with <span class="keyword cmdname">mqueue</span></th>

    <th class="entry" valign="top" id="d2223958e515">Entry with <span class="keyword cmdname">mq</span></th>

  </tr>

  </thead>


  <tbody class="tbody">
  <tr>
    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><samp class="ph codeph">/entry</samp></td>

    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><span class="ph filepath">/dev/mqueue/entry</span></td>

    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><span class="ph filepath">/dev/mq/entry</span></td>

  </tr>


  <tr>
    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><samp class="ph codeph">entry</samp></td>

    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><span class="ph filepath">/dev/mqueue/tmp/entry</span></td>

    <td class="entry" valign="top" headers="d2223958e506 d2223958e510 d2223958e515 "><span class="ph filepath">/dev/mq/tmp/entry</span></td>

  </tr>


  </tbody>

  </table>
</div>


<div class="note note"><span class="notetitle">Note:</span> 
        <ul class="ul" id="mq_open__ul_lb2_pxl_d1c">
          <li class="li"> If you want to open a queue on another node, you have to use the traditional
              (<span class="keyword cmdname">mqueue</span>) implementation and specify the name as
                <span class="ph filepath">/net/<var class="keyword varname">node</var>/<var class="keyword varname">mqueue_location</var></span>.
            Here, <var class="keyword varname">node</var> is the node name and <var class="keyword varname">mqeueue_location</var>
            is the device entry for the queue under <span class="ph filepath">/dev/mqueue</span> (on the remote
            node). For instance, if you want to open the queue at
              <span class="ph filepath">/dev/mqueue/mylocalqueue</span> on a node named <tt class="ph tt">NTO1</tt>, you must
            use the name <span class="ph filepath">/net/NTO1/mylocalqueue</span> in calling
              <span class="keyword apiname">mq_open()</span>.
            <p class="p">Note the difference in the path syntax required for QNX SDP 7.0 as compared to
            earlier releases (i.e., 6.X). In this later release, you must <em class="ph i">not</em> include
              <span class="ph filepath">/dev/mqueue</span> in the path of the message queue. </p>
</li>

          <li class="li">
            Message queues persistâlike filesâeven after the processes
            that created them end. A message
            queue is destroyed after a process has unlinked it by calling <span class="keyword apiname">mq_unlink()</span>
            and all open connections to the queue have been closed.</li>

        </ul>

      </div>


</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
A valid message queue descriptor if the queue is successfully created,
or -1 (<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a> is set).
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EACCES</span></dt>

<dd class="dd">The message queue exists, and you don't have 
  permission to open the queue under the given <var class="keyword varname">oflag</var>, 
  or the message queue doesn't exist, and you don't have permission to create one.
</dd>




<dt class="dt dlterm"><span class="keyword const">EEXIST</span></dt>

<dd class="dd">You specified the <span class="keyword const">O_CREAT</span> and <span class="keyword const">O_EXCL</span> flags 
  in <var class="keyword varname">oflag</var>, and the queue <var class="keyword varname">name</var> exists.
</dd>




<dt class="dt dlterm"><span class="keyword const">EINTR</span></dt>

<dd class="dd">The operation was interrupted by a signal.</dd>




<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">You specified the <span class="keyword const">O_CREAT</span> flag in <var class="keyword varname">oflag</var>, and <var class="keyword varname">mq_attr</var> 
  wasn't <span class="keyword const">NULL</span>, but some values in the <span class="keyword dtype">mq_attr</span> structure were invalid.
</dd>




<dt class="dt dlterm"><span class="keyword const">ELOOP</span></dt>

<dd class="dd">Too many levels of symbolic links or prefixes.</dd>




<dt class="dt dlterm"><span class="keyword const">EMFILE</span></dt>

<dd class="dd">Too many message queue descriptors or file descriptors are in use by the calling process.</dd>




<dt class="dt dlterm"><span class="keyword const">ENAMETOOLONG</span>  </dt>

<dd class="dd">The length of <var class="keyword varname">name</var> exceeds <span class="keyword const">PATH_MAX</span>.</dd>




<dt class="dt dlterm"><span class="keyword const">ENFILE</span></dt>

<dd class="dd">Too many message queues are open in the system.</dd>




<dt class="dt dlterm"><span class="keyword const">ENOENT</span></dt>

<dd class="dd">You didn't set the <span class="keyword const">O_CREAT</span> flag, and the queue <var class="keyword varname">name</var> doesn't exist.</dd>




<dt class="dt dlterm"><span class="keyword const">ENOSPC</span></dt>

<dd class="dd">The message queue server has run out of memory.</dd>


  
    <dt class="dt dlterm"><span class="keyword const">EPERM</span></dt>

    <dd class="dd">The process doesn't have the necessary ability to connect
              (<span class="keyword const">PROCMGR_AID_CHANNEL_CONNECT</span>).</dd>

  

<dt class="dt dlterm"><span class="keyword const">ENOSYS</span></dt>

<dd class="dd">The message queue manager
  (<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html"><span class="keyword cmdname">mq</span></a>
  or
  <a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mqueue.html"><span class="keyword cmdname">mqueue</span></a>)
  isn't running.
</dd>



</dl>


</div>


<div class="section" id="mq_open__Examples"><h2 class="title sectiontitle">Examples:</h2>


<pre class="pre codeblock">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mqueue.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#define MAX_MSG_SIZE 4096
#define MAX_MSGS     2

int main( void )
{
  mqd_t msg_queue;
  int   ret, i;
  int   msg_num = 0;
  unsigned int prio;
  char  send_msg[MAX_MSG_SIZE];
  char  received_msg[MAX_MSG_SIZE];
  ssize_t received_len;
  struct timespec abs_timeout;
  struct mq_attr attrs;

  /* Open a message queue. We'll restrict the number of messages so that the
     queue fills up quickly. */

  memset(&amp;attrs, 0, sizeof attrs);
  attrs.mq_maxmsg = MAX_MSGS;
  attrs.mq_msgsize = MAX_MSG_SIZE;
  msg_queue = mq_open( "/my_queue", O_RDWR | O_CREAT, S_IRWXU | S_IRWXG, &amp;attrs );
  if (msg_queue == -1) {
     perror ("mq_open()");
     return EXIT_FAILURE;
  }

  printf ("Successfully opened my_queue:\n");

  /* Get the queue's attributes. */

  ret = mq_getattr (msg_queue, &amp;attrs);
  if (ret == -1) {
     perror ("mq_getattr()");
     return EXIT_FAILURE;
  }

  printf ("  Flags: %lx; max messages: %ld; max message size: %ld\n",
     attrs.mq_flags, attrs.mq_maxmsg, attrs.mq_msgsize);
  printf ("  Messages: %ld; send waits: %ld; receive waits: %ld\n\n",
     attrs.mq_curmsgs, attrs.mq_sendwait, attrs.mq_recvwait);

  /* Send enough messages to fill the queue. */

  for (i=1; i &lt;= MAX_MSGS; i++)
  {
    msg_num++;
    sprintf (send_msg, "This is message number %d.", msg_num);
    ret = mq_send (msg_queue, send_msg, sizeof(send_msg), 5);
    if (ret == -1) {
       perror ("mq_send()");
       return EXIT_FAILURE;
    }

    ret = mq_getattr (msg_queue, &amp;attrs);
    if (ret == -1) {
       perror ("mq_getattr()");
       return EXIT_FAILURE;
    }

    printf ("After sending:\n");
    printf ("  Messages: %ld; send waits: %ld; receive waits: %ld\n\n",
            attrs.mq_curmsgs, attrs.mq_sendwait, attrs.mq_recvwait);
  }

  /* Send a message, specifying a time limit. This should time out
     because the queue is full. */

  clock_gettime(CLOCK_REALTIME, &amp;abs_timeout);
  abs_timeout.tv_sec += 1;

  msg_num++;
  sprintf (send_msg, "This is message number %d.", msg_num);
  ret = mq_timedsend (msg_queue, send_msg, sizeof(send_msg), 5, &amp;abs_timeout);
  if (ret == -1) {
     if (errno == ETIMEDOUT) {
        printf ("mq_timedsend() timed out:\n");
     } else {
        perror ("mq_timedsend()");
        return EXIT_FAILURE;
     }
  } else {
    printf ("After sending with a time limit:\n");
  }

  ret = mq_getattr (msg_queue, &amp;attrs);
  if (ret == -1) {
     perror ("mq_getattr()");
     return EXIT_FAILURE;
  }

  printf ("  Messages: %ld; send waits: %ld; receive waits: %ld\n\n",
     attrs.mq_curmsgs, attrs.mq_sendwait, attrs.mq_recvwait);

  /* Receive enough messages to empty the queue. */

  for (i=1; i &lt;= MAX_MSGS; i++)
  {
    received_len = mq_receive (msg_queue, received_msg, MAX_MSG_SIZE, &amp;prio);
    if (received_len == -1) {
       perror ("mq_receive()");
       return EXIT_FAILURE;
    }

    printf ("After receiving:\n");
    printf ("  Length: %ld; priority: %d; msg: \"%s\"\n", received_len, prio, received_msg);

    ret = mq_getattr (msg_queue, &amp;attrs);
    if (ret == -1) {
       perror ("mq_getattr()");
       return EXIT_FAILURE;
    }

    printf ("  Messages: %ld; send waits: %ld; receive waits: %ld\n\n",
       attrs.mq_curmsgs, attrs.mq_sendwait, attrs.mq_recvwait);
  }

  /* Receive a message, specifying a time limit. This should time out
     because the queue is now empty. */

  clock_gettime(CLOCK_REALTIME, &amp;abs_timeout);
  abs_timeout.tv_sec += 1;

  received_len = mq_timedreceive (msg_queue, received_msg, MAX_MSG_SIZE, &amp;prio,
                                  &amp;abs_timeout);
  if (received_len == -1) {
     if (errno == ETIMEDOUT) {
        printf ("mq_timedreceive() timed out:\n");
     } else {
        perror ("mq_timedreceive()");
        return EXIT_FAILURE;
     }
  } else {
    printf ("After receiving, specifying a time limit:\n");
    printf ("  Length: %ld; priority: %d; msg: \"%s\"\n", received_len, prio, received_msg);
  }

  ret = mq_getattr (msg_queue, &amp;attrs);
  if (ret == -1) {
     perror ("mq_getattr()");
     return EXIT_FAILURE;
  }

  printf ("  Messages: %ld; send waits: %ld; receive waits: %ld\n",
     attrs.mq_curmsgs, attrs.mq_sendwait, attrs.mq_recvwait);

  /* Unlink and then close the message queue. */
  ret = mq_unlink ("/my_queue");
  if (ret == -1) {
     perror ("mq_unlink()");
     return EXIT_FAILURE;
  }

  ret = mq_close (msg_queue);
  if (ret == -1) {
     perror ("mq_close()");
     return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</pre>

</div>


<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">POSIX 1003.1 MSG</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2223958e850">Safety:</th>
<th class="entry" valign="top" id="d2223958e852">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">Signal handler</td>
<td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">Thread</td>
<td class="entry" valign="top" headers="d2223958e850 d2223958e852 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Message_queues.html" title="POSIX message queues (System Architecture)">POSIX message queues (System Architecture)</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.technotes/topic/managing_mq_mqueue.html" title="POSIX Message Queues: Two Implementations (Technotes)">POSIX Message Queues: Two Implementations (Technotes)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_close.html" title="Close a message queue">mq_close()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_getattr.html" title="Get a message queue's attributes">mq_getattr()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_notify.html" title="Ask to be notified when there's a message in the queue">mq_notify()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_receive.html" title="Receive a message from a queue">mq_receive()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_send.html" title="Send a message to a queue">mq_send()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_setattr.html" title="Set a queue's attributes">mq_setattr()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_timedreceive.html" title="Receive a message from a message queue">mq_timedreceive(), mq_timedreceive_monotonic()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_timedsend.html" title="Send a message to a message queue">mq_timedsend(), mq_timedsend_monotonic()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/mq_unlink.html" title="Remove a queue">mq_unlink()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html" title="mq (Utilities Reference)">mq (Utilities Reference)</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mqueue.html" title="mqueue (Utilities Reference)">mqueue (Utilities Reference)</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>