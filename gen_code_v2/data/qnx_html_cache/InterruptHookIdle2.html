
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="InterruptHookIdle2()" /><meta name="abstract" content="Attach an &#147;idle&#148; interrupt handler" /><meta name="description" content="Attach an &#147;idle&#148; interrupt handler" /><meta name="indexterms" content="InterruptHookIdle2()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-i.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.prog/topic/inthandler.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattach.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattacharray.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattachevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptdetach.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="interrupthookidle2" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>InterruptHookIdle2()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="interrupthookidle2">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-i.html" title="I">I</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-i.html" title="I"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">I</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">InterruptHookIdle2()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>



<div class="body refbody"><p class="shortdesc"><em class="ph i">Attach an <span class="q">&#147;idle&#148;</span> interrupt handler</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/neutrino.h&gt;

int InterruptHookIdle2(
       void (*<var class="keyword varname">handler</var>)( unsigned <var class="keyword varname">cpu</var>,
                        struct syspage_entry *<var class="keyword varname">spp</var>,
                        struct _idle_hook *<var class="keyword varname">ihp</var> ),
       unsigned <var class="keyword varname">flags</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">handler</var></dt>

<dd class="dd">A pointer to the handler function; see below.</dd>




<dt class="dt dlterm"><var class="keyword varname">flags</var></dt>

<dd class="dd">There are currently no flags that apply; specify 0 for this argument.

  

  

  
</dd>



</dl>

</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>

<p class="p">Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">






The <span class="keyword apiname">InterruptHookIdle2()</span> kernel call attaches the specified
handler to a synthetic interrupt, which is generated when a processor becomes idle.
This handler is typically used to implement power management features.
The simplest idle handler consists of a <samp class="ph codeph">halt</samp> instruction.
</p>


<p class="p">
Before calling this function, the thread must
have the <span class="keyword const">PROCMGR_AID_INTERRUPT</span> ability enabled.
  For more information, see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.
  
Otherwise the attachment fails with an error code of <span class="keyword const">EPERM</span>.
</p>


<p class="p">
To detach the interrupt handler, call
<a class="xref" href="interruptdetach.html" title="Detach an interrupt handler by ID"><span class="keyword apiname">InterruptDetach()</span></a>;
you can't pass <span class="keyword const">NULL</span> for the <var class="keyword varname">handler</var> argument.
</p>


<p class="p">
The arguments to the <var class="keyword varname">handler</var> function are:
</p>


<dl class="dl">

<dt class="dt dlterm"><span class="keyword dtype">unsigned</span> <var class="keyword varname">cpu</var></dt>

<dd class="dd">The CPU number that this hook call is occurring on.</dd>




<dt class="dt dlterm"><span class="keyword dtype">struct syspage_entry *</span> <var class="keyword varname">spp</var></dt>

<dd class="dd">A pointer to a writable version of the system page.
  For more information, see the
  <a class="xref" href="../../../com.qnx.doc.neutrino.building/topic/syspage/syspage_about.html">System Page</a>
  chapter of <cite class="cite">Building Embedded Systems</cite>, as well as the
  <a class="xref" href="../s/syspage_entry.html" title="Return an entry from the system page"><span class="keyword apiname">SYSPAGE_ENTRY()</span></a>
  macro.
</dd>




<dt class="dt dlterm"><span class="keyword dtype">struct _idle_hook *</span> <var class="keyword varname">ihp</var></dt>

<dd class="dd">A pointer to an <span class="keyword dtype">_idle_hook</span> structure that
  the kernel and the handler use to exchange information.
</dd>



</dl>


<p class="p">
The handler function is invoked with a very limited amount of stack space, so it shouldn't use large automatic arrays.
It's also invoked in such a manner that it can be aborted at any time and restarted from the beginning,
with no user notification.
It isn't allowed to make any OS service calls (e.g., message passing).
</p>


<p class="p">

The <span class="keyword dtype">_idle_hook</span> structure is defined in
<span class="ph filepath">&lt;sys/neutrino.h&gt;</span> as follows:
</p>


<pre class="pre codeblock">
struct _idle_hook {
        unsigned                hook_size;
        unsigned                cmd;
        unsigned                mode;
        unsigned                latency;
        uint64_t                next_fire;
        uint64_t                curr_time;
        uint64_t                tod_adjust;
        unsigned                resp;
        struct {
                unsigned        length;
                unsigned        scale;
        } time;
        struct sigevent         trigger;
        unsigned                *intrs;
        unsigned                block_stack_size;
};
</pre>


<p class="p">
The members include:
</p>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">hook_size</var></dt>

<dd class="dd">The size of the <span class="keyword dtype">_idle_hook</span> structure, in bytes.</dd>




<dt class="dt dlterm"><var class="keyword varname">cmd</var></dt>

<dd class="dd">The kernel sets this member to one of the following values, to indicate the phase of the call
  (see below for more details):

  <ul class="ul">
  <li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_SETUP</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_WAKEUP</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_ONLINE</span>
    
  </li>


  </ul>

</dd>




<dt class="dt dlterm"><var class="keyword varname">mode</var></dt>

<dd class="dd">The meaning of this member depends on <var class="keyword varname">cmd</var>:

  <ul class="ul">
  <li class="li">For <span class="keyword const">_NTO_IH_CMD_SLEEP_SETUP</span>, <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span>, and
    <span class="keyword const">_NTO_IH_CMD_SLEEP_WAKEUP</span>, this value (if nonzero) is the sleep mode to set.
  </li>


  <li class="li">For <span class="keyword const">_NTO_IH_CMD_SLEEP_ONLINE</span>, it's the CPU number that's being returned to operation.</li>


  </ul>

</dd>




<dt class="dt dlterm"><var class="keyword varname">latency</var></dt>

<dd class="dd">The maximum latency, in nanoseconds, that the CPU is allowed to have when responding to an interrupt.
  If the kernel is taking the CPU offline, it sets this field to ~0,
  
  and the handler should choose the absolute lowest power mode, which should be off.
</dd>




<dt class="dt dlterm"><var class="keyword varname">next_fire</var></dt>

<dd class="dd">The time, in nanoseconds since the system was booted, when the next timer is to fire.</dd>




<dt class="dt dlterm"><var class="keyword varname">curr_time</var></dt>

<dd class="dd">The current time of day, in nanoseconds since the system was booted.</dd>




<dt class="dt dlterm"><var class="keyword varname">tod_adjust</var></dt>

<dd class="dd">The number of nanoseconds to add to <var class="keyword varname">curr_time</var> to convert it to the time of day.</dd>




<dt class="dt dlterm"><var class="keyword varname">resp</var></dt>

<dd class="dd">The response from the handler; a bitwise OR of zero or more of the following:

<ul class="ul">
  <li class="li"><span class="keyword const">_NTO_IH_RESP_NEEDS_BLOCK</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_NEEDS_WAKEUP</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_NEEDS_ONLINE</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_SYNC_TIME</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_SYNC_TLB</span>
    
  </li>


  
  <li class="li"><span class="keyword const">_NTO_IH_RESP_SUGGEST_OFFLINE</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_SLEEP_MODE_REACHED</span>
    
  </li>


  <li class="li"><span class="keyword const">_NTO_IH_RESP_DELIVER_INTRS</span>
    
  </li>


  </ul>


  <p class="p">
  See below for more details.
  </p>

</dd>




<dt class="dt dlterm"><var class="keyword varname">time.length</var></dt>

<dd class="dd">Filled in by the handler.
  The number of time units that the system tick (sometimes called <span class="q">&#147;timer tick&#148;</span>) interrupt has been disabled.
</dd>




<dt class="dt dlterm"><var class="keyword varname">time.scale</var></dt>

<dd class="dd">Filled in by the handler.
  A scale factor such that <var class="keyword varname">time.length</var> * <var class="keyword varname">time.scale</var> gives
  the number of nanoseconds that the system tick interrupt has been disabled.
</dd>




<dt class="dt dlterm"><var class="keyword varname">trigger</var></dt>

<dd class="dd">A
  <a class="xref" href="../s/sigevent.html" title="Structure that describes an event"><span class="keyword dtype">sigevent</span></a>
  that the handler wants the kernel to deliver (if the <var class="keyword varname">sigev_notify</var> member
  isn't <span class="keyword const">SIGEV_NONE</span>).
  The target thread is the one that called <span class="keyword apiname">InterruptHookIdle2()</span>.
</dd>




<dt class="dt dlterm"><var class="keyword varname">intrs</var></dt>

<dd class="dd">A pointer to an array where each bit, if set to 1 by the handler, indicates an interrupt
  for which the kernel should arrange to invoke ISRs and deliver events specified by
  <span class="keyword apiname">InterruptAttach()</span>, <span class="keyword apiname">InterruptAttachArray()</span>,
  or <span class="keyword apiname">InterruptAttachEvent()</span>.
  The size of this array is based on the <var class="keyword varname">intrinfo</var> section of the system page;
  it needs to be big enough to handle all the interrupts specified there (basically, total up the
  <var class="keyword varname">num_vector</var> fields).

  <p class="p">
  The <span class="keyword const">_NTO_IH_RESP_DELIVER_INTRS</span> bit must be set in the <var class="keyword varname">resp</var> field
  for the kernel to check the contents of the array.
  See below for details on how to determine the bit(s) to be set.
  </p>

</dd>




<dt class="dt dlterm"><var class="keyword varname">block_stack_size</var></dt>

<dd class="dd">Before invoking the handler with <span class="keyword const">_NTO_IH_CMD_SLEEP_SETUP</span>, the kernel sets this
  field to the current stack size for <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span>.
  On return, if the idle hook places a larger value in the field, the kernel attempts to grow the
  block stack to the newly requested value.
  On entry to the idle hook for <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span>, you can check the size again.
  If it's less than the size that you requested, the grow request failed due to lack of memory.
</dd>



</dl>


<p class="p">
The idle hook handler may be called up to three times per entry to or exit from the sleep state, depending on
how the handler function responds to each of the previous calls.
The kernel sets the <var class="keyword varname">cmd</var> field for each invocation:
</p>


<ol class="ol">
<li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_SETUP</span>

  <p class="p">
  In this call, the handler should set up the chip registers to enter the selected sleep state.
  The handler isn't allowed to actually enter a sleep state or block waiting for an interrupt or event.
  </p>


  <p class="p">
  The usual activity for the handler at this point is to simply respond that it wants wants to be called with
  <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span> at the appropriate time.
  However, if there is any long-running hardware preparation for low-power mode (e.g., writing to a register,
  then either waiting or polling a register until ready), you can use this callback to kick things off,
  so that the hardware will likely to be ready when the callback for <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span> is called,
  when the hardware can be fully configured for low-power mode.
  </p>

</li>


<li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span>

  <p class="p">
  In this call, the handler can continue whatever setup is needed from the first call,
  and it should actually do what's needed to enter the selected sleep state.
  If all that's needed to actually enter the sleep state is for the chip to execute its halt instruction
  (<samp class="ph codeph">HLT</samp> on x86, <samp class="ph codeph">WFI</samp> on ARM, etc.), then that's all the handler has to do.
  </p>


  <div class="note note"><span class="notetitle">Note:</span> 
  The handler is invoked from the context of a CPU-specific idle thread that runs at Ring 1 on  x86_64,
  in Supervisor mode on ARMv7, and EL1 on AArch64.
  Ensure you have enough privilege to do what's required;
  for example, Intel's <samp class="ph codeph">HLT</samp> instruction isn't allowed in Ring 1.
  </div>

</li>


<li class="li"><span class="keyword const">_NTO_IH_CMD_SLEEP_WAKEUP</span>

  <p class="p">
  At this point, an interrupt has occurred that has released the CPU from its sleep state.
  The handler should restore whatever state it needs to.
  </p>


  <p class="p">
  This time, the callback is invoked from an interrupt context, with interrupts enabled, before the
  interrupt-specific ISR is invoked.
  You should provide information regarding missed time to the idle hook response <em class="ph i">before</em>
  the low-power code transfers execution back to the OS.
  </p>

</li>


</ol>


<p class="p">
For each of these calls, the handler fills in the <var class="keyword varname">resp</var> field with a bitset indicating
what the kernel needs to do:
</p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" width="100%" frame="border" border="1" rules="all">

<thead class="thead" align="left">
<tr>
  <th class="entry" valign="top" id="d1991983e690">Bit</th>

  <th class="entry" valign="top" id="d1991983e693">Description</th>

</tr>

</thead>


<tbody class="tbody">
<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_NEEDS_BLOCK</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">If set after the first handler call, the kernel will invoke the handler with the
    <span class="keyword const">_NTO_IH_CMD_SLEEP_BLOCK</span> state.
  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_NEEDS_WAKEUP</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">If set after the first handler call (or second, if the second call has been requested),
    the kernel will invoke the handler with the <span class="keyword const">_NTO_IH_CMD_SLEEP_WAKEUP</span> state.
  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_NEEDS_ONLINE</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">If the selected mode is such that an interprocessor interrupt (IPI) isn't sufficient
    to cause the CPU to respond (e.g., it's offline), the handler should set this bit.
    The kernel, when it decides to online the CPU, invokes the idle hook (on a different CPU) with
     the <var class="keyword varname">cmd</var> field set to <span class="keyword const">_NTO_IH_CMD_SLEEP_ONLINE</span>.
    The <var class="keyword varname">mode</var> field holds the CPU number that is being returned to operation.
  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_SYNC_TIME</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><p class="p">After the handler returns, the kernel will add <var class="keyword varname">time.length</var> *
    <var class="keyword varname">time.scale</var> nanoseconds to the <samp class="ph codeph">SYSPAGE_ENTRY(qtime)-&gt;nsec</samp> field.</p>

    <p class="p">In QNX Neutrino 7.1 or later, the kernel uses the <span class="keyword apiname">ClockCycles()</span> function to detect if system ticks
      (or <span class="q">&#147;timer ticks&#148;</span>) are lost and thus, determine how much time it should add to this field.
      This design makes this flag redundant unless there's the possibility
      that the hardware is interfered with during the time that the system tick interrupt is disabled.
      If this happens, for whatever reason, you'll need to compensate for the lack of timely delivery of system ticks.</p>

    <p class="p">If you freeze the hardware behind <span class="keyword apiname">ClockCycles()</span> and you
      want your system to reflect the time that it was in low-power mode with system ticks disabled,
      you must either correct that underlying hardware to reflect the time when system ticks were disabled,
      or set the <span class="keyword const">_NTO_IH_RESP_SYNC_TIME</span> flag so the kernel can apply the time correction
      after the handler returns.</p>

  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_SYNC_TLB</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">After the handler returns, the kernel will resynchronize the translation lookaside buffer (TLB) state
    (the TLB wasn't being notified of modifications from other CPU's during the sleep state).

    <p class="p">
    The kernel crashes if it gets this response.
    </p>

  </td>

</tr>




<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_SUGGEST_OFFLINE</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">This allows the handler to suggest to the kernel that it might be a good idea to offline this CPU.
    The CPU must be marked as being available for dynamic offlining, and the kernel is free to ignore the suggestion
    (and it currently does).
  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_SLEEP_MODE_REACHED</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">This bit indicates that the sleep mode requested was actually entered by the hardware.
     The kernel doesn't do anything with this bit, but it can be used to gather statistics on how
     much power savings are being obtained.
  </td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 "><span class="keyword const">_NTO_IH_RESP_DELIVER_INTRS</span></td>

  <td class="entry" valign="top" headers="d1991983e690 d1991983e693 ">If set, this bit indicates that the handler turned on bits in the <var class="keyword varname">intrs</var> array,
     and the kernel needs to perform interrupt delivery processing for the indicated interrupts.
  </td>

</tr>


</tbody>

</table>
</div>


<p class="p"><strong class="ph b">Indicating interrupts for delivery processing</strong></p>


<p class="p">
If an unmasked interrupt occurs while the CPU is asleep and, for some reason, it will not cause
CPU interrupt exception processing to occur when the CPU wakes up, the hook code must tell
the kernel about the interrupt so that it can arrange to invoke the handlers
(<span class="keyword apiname">InterruptAttach()</span> or <span class="keyword apiname">InterruptAttachArray()</span>)
or deliver the <span class="keyword dtype">sigevent</span>s
(<span class="keyword apiname">InterruptAttachEvent()</span>) for that level.
</p>


<p class="p">
The handler indicates this by turning on the appropriate bit(s) in the <var class="keyword varname">intrs</var> array
and setting <span class="keyword const">_NTO_IH_RESP_DELIVER_INTRS</span> in the <var class="keyword varname">resp</var> field.
</p>


<p class="p">
To determine the corresponding bit for each interrupt, examine the system page's <var class="keyword varname">intrinfo</var>
section and look at the number of interrupts that each controller is responsible for.
If the first controller is responsible for <var class="keyword varname">N</var> interrupts, then the interrupt numbers are
0 ... (<var class="keyword varname">N</var>-1).
If the second controller has <var class="keyword varname">M</var> interrupts, then its numbers are <var class="keyword varname">N</var> ...
(<var class="keyword varname">N</var> + <var class="keyword varname">M</var> - 1), and so on.
If you want to indicate that interrupt <var class="keyword varname">X</var> has occurred, set the following bit:
</p>


<pre class="pre codeblock">
idle_hook_ptr-&gt;intrs[X / (sizeof(unsigned)*CHAR_BIT)] |=
   1U &lt;&lt; (X % (sizeof(unsigned)*CHAR_BIT));
</pre>




<p class="p"><strong class="ph b">Blocking states</strong></p>




<p class="p">
This call doesn't block.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
An interrupt function ID, or -1 if an error occurs
(<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>
is set).
</p>


<p class="p">
Use the returned ID with
<a class="xref" href="interruptdetach.html" title="Detach an interrupt handler by ID"><span class="keyword apiname">InterruptDetach()</span></a>
to detach this interrupt handler.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">


<dt class="dt dlterm"><span class="keyword const">EAGAIN</span></dt>

<dd class="dd">All kernel interrupt entries are in use.</dd>




<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">The <var class="keyword varname">handler</var> argument is <span class="keyword const">NULL</span>.</dd>




<dt class="dt dlterm"><span class="keyword const">EPERM</span></dt>

<dd class="dd">The calling process doesn't have the required permission (see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>).
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d1991983e1007">Safety:</th>
<th class="entry" valign="top" id="d1991983e1009">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Cancellation point</td>
<td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Signal handler</td>
<td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Thread</td>
<td class="entry" valign="top" headers="d1991983e1007 d1991983e1009 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.prog/topic/inthandler.html" title="Writing an Interrupt Handler (QNX Neutrino Programmer's Guide)">Writing an Interrupt Handler (<span class="keyword">QNX Neutrino</span> Programmer's Guide)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattach.html" title="Attach an Interrupt Service Routine (ISR) to an interrupt source">InterruptAttach(), InterruptAttach_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattacharray.html" title="Attach an Interrupt Service Routine (ISR) that returns an array of sigevents to an interrupt source">InterruptAttachArray(), InterruptAttachArray_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptattachevent.html" title="Attach an event to an interrupt source">InterruptAttachEvent(), InterruptAttachEvent_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/i/interruptdetach.html" title="Detach an interrupt handler by ID">InterruptDetach(), InterruptDetach_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" title="Control a process's ability to perform certain operations">procmgr_ability()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-i.html" title="I"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">I</span></a></span>  </div>
</body>
</html>