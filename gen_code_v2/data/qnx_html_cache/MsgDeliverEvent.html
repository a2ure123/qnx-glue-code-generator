
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="MsgDeliverEvent(), MsgDeliverEvent_r()" /><meta name="abstract" content="Deliver an event through a channel" /><meta name="description" content="Deliver an event through a channel" /><meta name="indexterms" content="MsgDeliverEvent(), MsgDeliverEvent_r()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Events.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgregisterevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsend.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendpulse.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendpulseptr.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgunregisterevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgverifyevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/sigevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/signalwaitinfo.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/signalwaitinfomask.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgverifyevent.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="msgdeliverevent" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>MsgDeliverEvent(), MsgDeliverEvent_r()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="msgdeliverevent">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">MsgDeliverEvent()</span>, <span class="keyword apiname">MsgDeliverEvent_r()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Deliver an event through a channel</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/neutrino.h&gt;

int MsgDeliverEvent( int <var class="keyword varname">rcvid</var>,
                     const struct sigevent* <var class="keyword varname">event</var> );

int MsgDeliverEvent_r( 
                   int <var class="keyword varname">rcvid</var>,
                   const struct sigevent* <var class="keyword varname">event</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">rcvid</var></dt>

<dd class="dd">The context in which the event should be delivered. The value of the receive ID can be:
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
              
              
              
              <thead class="thead" align="left">
                <tr>
                  <th class="entry" valign="top" width="20%" id="d2232238e66">Value</th>

                  <th class="entry" valign="top" width="40%" id="d2232238e69">Meaning</th>

                  <th class="entry" valign="top" width="40%" id="d2232238e72">Event registration</th>

                </tr>

              </thead>

              <tbody class="tbody">
                <tr>
                  <td class="entry" valign="top" width="20%" headers="d2232238e66 ">&gt; 0</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e69 ">The client identified by the value returned to the server when it receives a message from a client
                    using <span class="keyword apiname">MsgReceive*()</span>.</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e72 ">The client must have registered the event by calling <span class="keyword apiname">MsgDeliverEvent()</span> with a coid to the server passed as the connection ID (coid).</td>

                </tr>

                <tr>
                  <td class="entry" valign="top" width="20%" headers="d2232238e66 ">0</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e69 ">Deliver the event to the active thread (see below).</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e72 ">The event doesn't need to be registered.</td>

                </tr>

                <tr>
                  <td class="entry" valign="top" width="20%" headers="d2232238e66 ">&lt; 0</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e69 ">Deliver the event to the thread with a thread ID that is the absolute value
                    of <var class="keyword varname">rcvid</var>.</td>

                  <td class="entry" valign="top" width="40%" headers="d2232238e72 ">The event doesn't need to be registered.</td>

                </tr>

              </tbody>

            </table>
</div>
 </dd>




<dt class="dt dlterm"><var class="keyword varname">event</var></dt>

<dd class="dd">A pointer to a
  <a class="xref" href="../s/sigevent.html" title="Structure that describes an event"><span class="keyword dtype">sigevent</span></a>
  structure that contains the event you want to send.
  These events are defined in <span class="ph filepath">&lt;sys/siginfo.h&gt;</span>.
  The type of event is placed in <var class="keyword varname">event.sigev_notify</var>.
  
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">




The <span class="keyword apiname">MsgDeliverEvent()</span> and <span class="keyword apiname">MsgDeliverEvent_r()</span>
kernel calls deliver an <var class="keyword varname">event</var> from a server to a client through a channel connection.
They're typically used to perform async IO and async event notification to clients that don't want to block on a server.
</p>


<p class="p">
These functions are identical except in the way they indicate errors.
See the <a class="xref" href="#msgdeliverevent__Returns">Returns</a> section for details.
</p>


<p class="p">
Although the server can explicitly send any event it desires, it's
more typical for the server to receive a <span class="keyword dtype">struct sigevent</span>
in a message from the client that already
contains this data. The message also contains information for the
server indicating the conditions on when to notify the client with the
event. The server then saves the <var class="keyword varname">rcvid</var> from
<span class="keyword apiname">MsgReceive*()</span> and the event from the message without
needing to examine the event in any way. When the trigger conditions are
met in the server, such as data becoming available, the server calls
<span class="keyword apiname">MsgDeliverEvent()</span> with the saved <var class="keyword varname">rcvid</var> and
<var class="keyword varname">event</var>.
</p>


<p class="p">
In QNX Neutrino 7.0.1 or later, the <span class="keyword dtype">sigevent</span> can contain the handle for a secure event
that the client registered by calling
<a class="xref" href="msgregisterevent.html" title="Register a secure event"><span class="keyword apiname">MsgRegisterEvent()</span></a>.
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Events.html">Events</a>&#148;</span>
in the <span class="q">&#147;Interprocess Communication (IPC)&#148;</span> chapter of the <cite class="cite">System Architecture</cite> guide.
</p>


<p class="p">


You can use the <span class="keyword const">SIGEV_SIGNAL</span> set of notifications
to create an asynchronous design in which the client is interrupted
when the event occurs. The client can make this synchronous by using the 
<a class="xref" href="../s/signalwaitinfo.html" title="Select a pending signal"><span class="keyword apiname">SignalWaitinfo()</span></a> 
kernel call to wait for the
signal. Where possible, you should use an event-driven synchronous design
that's based on <span class="keyword const">SIGEV_PULSE</span>. In this case, the
client sends messages to servers, and requests event notification
via a pulse.
</p>


<p class="p">
The notify types of <span class="keyword const">SIGEV_UNBLOCK</span> and
<span class="keyword const">SIGEV_INTR</span> are allowed, but aren't very useful with <span class="keyword apiname">MsgDeliverEvent()</span>.
<span class="keyword const">SIGEV_UNBLOCK</span> is typically used by the
<span class="keyword apiname">TimerTimeout()</span> kernel call, and <span class="keyword const">SIGEV_INTR</span>
is typically used with the <span class="keyword apiname">InterruptWait()</span> kernel call.
</p>


<p class="p">
You should use <span class="keyword apiname">MsgDeliverEvent()</span> when two processes need to
communicate with each other without the possibility of
deadlock. The blocking nature of <span class="keyword apiname">MsgSend*()</span> introduces a
hierarchy of processes in which <span class="q">&#147;sends&#148;</span> flow one way and
<span class="q">&#147;replies&#148;</span> the other way.
</p>


<p class="p">
In the following diagram, processes at the A level can send to
processes at the B or C level. Processes at the B level can send to the
C level but they should never send to the A level. Likewise, processes
at the C level can never send to those at the A or B level. To A, B and
C are servers. To B, A is a client and C is a server.
</p>


<div class="fig fignone">

<img class="image" src="../../images/msgsendpulse1.png" />
<span class="figcap">Figure 1. A hierarchy of processes.</span></div>


<p class="p">
These hierarchies are simple to establish and ensure a clean deadlock-free design.
If these rules are broken then deadlock can occur as shown below:
</p>


<div class="fig fignone">

<img class="image" src="../../images/msgsendpulse2.png" />
<span class="figcap">Figure 2. A deadlock when sending messages improperly among processes.</span></div>


<p class="p">
There are common situations which require communication to flow
backwards through the hierarchy. For example, A sends to B requesting
notification when data is available. B immediately replies to A. At some
point in the future, B will have the data A requested and will inform A.
B can't send a message to A because this might result in deadlock if A
decided to send to B at the same time.
</p>


<p class="p">
The solution is to have B use a nonblocking <span class="keyword apiname">MsgDeliverEvent()</span> to inform A.
A receives this pulse and sends a message to B requesting the data.
B then replies with the data. This is the basis for asynchronous IO. Clients
send to servers and where necessary, servers use pulses to request
clients to resend to them as needed. This is illustrated below:
</p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">

<thead class="thead" align="left">
<tr>
  <th class="entry" valign="top" id="d2232238e393">Message</th>

  <th class="entry" valign="top" id="d2232238e396">Use</th>

</tr>

</thead>


<tbody class="tbody">

<tr>
  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">A sends to B</td>

  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">Async IO request</td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">B replies to A</td>

  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">Request acknowledged</td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">B sends pulse to A</td>

  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">Requested data available</td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">A sends to B</td>

  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">Request for the data</td>

</tr>


<tr>
  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">B replies to A</td>

  <td class="entry" valign="top" headers="d2232238e393 d2232238e396 ">Reply with data</td>

</tr>


</tbody>

</table>
</div>


<div class="note note"><span class="notetitle">Note:</span> 
In client/server designs, you typically use <span class="keyword apiname">MsgDeliverEvent()</span> in the server, and 
<a class="xref" href="msgsendpulse.html" title="Send a pulse to a process"><span class="keyword apiname">MsgSendPulse()</span></a> 
in the client.
</div>


<p class="p">
Sometimes it might be convenient for a library that doesn't have the
<var class="keyword varname">rcvid</var> to deliver the event instead of handing it off to the server.
The library could interpret the <span class="keyword dtype">sigevent</span> itself, but this
duplicates what the kernel already knows how to do.
Instead, the library can call
<span class="keyword apiname">MsgDeliverEvent()</span> with a <var class="keyword varname">rcvid</var> of 0.
The kernel then creates an artificial <var class="keyword varname">rcvid</var> that references
the calling threadâas if a server had received the message from it
via <span class="keyword apiname">MsgReceive()</span>âand
then the rest of the <span class="keyword apiname">MsgDeliverEvent()</span> proceeds normally.
</p>


<p class="p">

If the client program replaces its process image
(e.g., by calling <a class="xref" href="../lib-e.html"><span class="keyword apiname">exec*()</span></a>)
with a setuid or setgid binary, the kernel sets the <span class="keyword const">_NTO_COF_INSECURE</span> flag
on the channel.
If this flag is set, calls to <span class="keyword apiname">MsgDeliverEvent()</span>
with an event type of <span class="keyword const">SIGEV_MEMORY</span> or <span class="keyword const">SIGEV_THREAD</span>
fail with an error of <span class="keyword const">EACCES</span>.
In QNX Neutrino 7.0 and later, only the kernel can clear this flag;
currently it stays set until the connection is detached.
</p>


<p class="p">
<span class="keyword apiname">MsgDeliverEvent()</span> checks the event before delivering it, and uses the error codes
listed below to indicate any problems found.
For <span class="keyword const">SIGEV_PULSE</span> events, the priority of the pulse must be in the range for the target process,
or (in QNX Neutrino 6.6 or later) that process must have the <span class="keyword const">PROCMGR_AID_PRIORITY</span> ability enabled (see
<a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>).
In QNX Neutrino 6.6 or later, if
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/p/procnto.html"><span class="keyword cmdname">procnto</span></a>
was started with an <span class="q">&#147;s&#148;</span> appended to the <span class="keyword option">-P</span> option, then
out-of-range priority requests use the maximum allowed value instead of resulting in an error.
A priority of 0 (which is reserved for the idle thread) is changed to 1.
</p>




<p class="p"><strong class="ph b">Blocking states</strong></p>




<p class="p">
None for the local case. In the network case:
</p>


<dl class="dl">

<dt class="dt dlterm" id="msgdeliverevent__state_reply"><span class="keyword const">STATE_REPLY</span></dt>

<dd class="dd">The calling thread is waiting for a network operation to complete.
  The calling thread is marked as REPLY-blocked on itself (the same process ID as the thread making the call).
  
</dd>



</dl>


<p class="p"><strong class="ph b">Native networking</strong></p>


<p class="p">
When you use <span class="keyword apiname">MsgDeliverEvent()</span> to communicate across a network, 
the return code isn't <span class="q">&#147;reliable&#148;</span>. In
the local case, <span class="keyword apiname">MsgDeliverEvent()</span> always
returns a correct success or failure value. But since
<span class="keyword apiname">MsgDeliverEvent()</span> <em class="ph i">must be nonblocking</em>,
in the networked case, the return value isn't guaranteed to
reflect the actual result on the client's node. This is
because <span class="keyword apiname">MsgDeliverEvent()</span> would have to block
waiting for the communications between the two
<span class="ph filepath">lsm-qnet.so</span> objects.
</p>


<p class="p">
Generally, this isn't a problem,
because <span class="keyword apiname">MsgDeliverEvent()</span> is for the benefit of
the client anywayâif the client no longer exists,
then the client obviously doesn't care that it didn't get
the event. The server usually delivers the event and then
goes about its business, regardless of the success or
failure of the event delivery.
</p>


</div>



<div class="section" id="msgdeliverevent__Returns"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
The only difference between these functions is the way they indicate errors:
</p>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword apiname">MsgDeliverEvent()</span></dt>

<dd class="dd">If an error occurs, this function returns -1 and sets
  <a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>.
  Any other value returned indicates success.
</dd>




<dt class="dt dlterm"><span class="keyword apiname">MsgDeliverEvent_r()</span></dt>

<dd class="dd">If successful, this function returns <span class="keyword const">EOK</span>. This function does <strong class="ph b">NOT</strong> set <var class="keyword varname">errno</var>, even on success.
  If an error occurs, it may return any value from the Errors section.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EACCES</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The <span class="keyword const">_NTO_COF_INSECURE</span> flag is set on the channel.
  In QNX Neutrino 7.0 and later, only the kernel can clear this flag.
  </li>


  <li class="li">(QNX Neutrino 7.0 or later) The <span class="keyword const">_NTO_COF_NOEVENT</span> flag is set on the channel.</li>


  <li class="li">(QNX Neutrino 7.0.1 or later) The 
    <a class="xref" href="../s/sigevent.html" title="Structure that describes an event"><span class="keyword dtype">sigevent</span></a>
    isn't an event handle, and connection accepts only <span class="keyword dtype">sigevent</span>s that were registered
    as secure events with
    <a class="xref" href="msgregisterevent.html" title="Register a secure event"><span class="keyword apiname">MsgRegisterEvent()</span></a>.
    
    
    
    
    
  </li>


  <li class="li">The target process's threads are being destroyed.</li>

  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">EAGAIN</span></dt>

<dd class="dd">The kernel has insufficient resources to enqueue the event.</dd>




<dt class="dt dlterm"><span class="keyword const">EBADF</span></dt>

<dd class="dd">The thread indicated by <var class="keyword varname">rcvid</var> had its connection detached.</dd>




<dt class="dt dlterm"><span class="keyword const">EBUSY</span></dt>

<dd class="dd">The event type is <span class="keyword const">SIGEV_THREAD</span> and the target process's threads are being destroyed
    or a core dump is being created for the target process.</dd>




<dt class="dt dlterm"><span class="keyword const">ECANCELED</span></dt>

<dd class="dd">The event couldn't be queued.</dd>




<dt class="dt dlterm"><span class="keyword const">EFAULT</span></dt>

<dd class="dd">A fault occurred when the kernel tried to access the buffers provided.</dd>




<dt class="dt dlterm"><span class="keyword const">EINVAL</span></dt>

<dd class="dd">The given event isn't valid; 
  for example, the type of notification might be invalid.
  Other meanings depend on the type of notification, and include:

  <ul class="ul">
  <li class="li"><span class="keyword const">SIGEV_MEMORY</span>: the memory operation specified by <var class="keyword varname">sigev_memop</var>
    isn't valid.
    
  </li>


  <li class="li"><span class="keyword const">SIGEV_PULSE</span>: the priority is out of range (e.g., greater than 255).
    
  </li>


  <li class="li"><span class="keyword const">SIGEV_SIGNAL</span>: the signal is out of range.
    
  </li>


  <li class="li"><span class="keyword const">SIGEV_SIGNAL_CODE</span>, <span class="keyword const">SIGEV_SIGNAL_THREAD</span>: the signal or the
    <var class="keyword varname">sigev_code</var> is out of range.
    
    
  </li>


  </ul>

</dd>




<dt class="dt dlterm"><span class="keyword const">ENXIO</span></dt>

<dd class="dd">The process that's supposed to receive a pulse is terminating.</dd>




<dt class="dt dlterm"><span class="keyword const">EPERM</span></dt>

<dd class="dd">For <span class="keyword const">SIGEV_PULSE</span> events, the priority of the pulse is outside the range for
  nonprivileged processes, and the target process doesn't have the <span class="keyword const">PROCMGR_AID_PRIORITY</span>
  ability enabled (see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>).
</dd>




<dt class="dt dlterm"><span class="keyword const">ESRCH</span></dt>

<dd class="dd">The thread indicated by <var class="keyword varname">rcvid</var> doesn't exist.</dd>




<dt class="dt dlterm"><span class="keyword const">ESRVRFAULT</span></dt>

<dd class="dd">A fault occurred in the server's address space when the kernel tried to write the pulse message
  to the server's receive message buffer (<span class="keyword const">SIGEV_PULSE</span> only).
</dd>




<dt class="dt dlterm"><span class="keyword const">ETIMEDOUT</span></dt>

<dd class="dd">A kernel timeout unblocked the call. See
  <a class="xref" href="../t/timertimeout.html" title="Set a timeout on a blocking state"><span class="keyword apiname">TimerTimeout()</span></a>.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Examples:</h2>


<p class="p">
The following example demonstrates how a client can request a server to notify it with a pulse
at a later time (in this case, after the server has slept for two seconds). 
The server side notifies the client using <span class="keyword apiname">MsgDeliverEvent()</span>.
</p>


<p class="p">
Here's the header file that's used by <span class="ph filepath">client.c</span> and <span class="ph filepath">server.c</span>:
</p>


<pre class="pre codeblock">
struct my_msg
{
   short type;
   struct sigevent event;
};

#define MY_PULSE_CODE _PULSE_CODE_MINAVAIL+5
#define MSG_GIVE_PULSE _IO_MAX+4
#define MY_SERV "my_server_name"
</pre>


<p class="p">
Here's the client side that fills in a <span class="keyword dtype">struct sigevent</span> and then receives a pulse:
</p>


<pre class="pre codeblock">
/* client.c */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/neutrino.h&gt;
#include &lt;sys/iomsg.h&gt;
#include &lt;sys/iofunc.h&gt;
#include &lt;sys/dispatch.h&gt;

#include "my_hdr.h"

int main( int argc, char **argv)
{
  int chid, coid, srv_coid, rcvid;
  struct my_msg msg;
  struct _pulse pulse;

  /* we need a channel to receive the pulse notification on */
  chid = ChannelCreate( 0 ); 

  /* and we need a connection to that channel for the pulse to be
     delivered on */
  coid = ConnectAttach( 0, 0, chid, _NTO_SIDE_CHANNEL, 0 );

  /* find the server */
  if ( (srv_coid = name_open( MY_SERV, 0 )) == -1)
  {
     printf("failed to find server, errno %d\n", errno );
     exit(1);
  }

  /* fill in the event structure for a pulse */
  SIGEV_PULSE_INIT( &amp;msg.event, coid, SIGEV_PULSE_PRIO_INHERIT, 
                    MY_PULSE_CODE, 0 );

  /* register the event with the side-channel connection id 
     from name_open() */
  MsgRegisterEvent(&amp;msg.event, srv_coid);
  msg.type = MSG_GIVE_PULSE;

  /* give the pulse event we initialized above to the server for
     later delivery */
  MsgSend( srv_coid, &amp;msg, sizeof(msg), NULL, 0 );

  /* wait for the pulse from the server */
  rcvid = MsgReceivePulse( chid, &amp;pulse, sizeof( pulse ), NULL );
  printf("got pulse with code %d, waiting for %d\n", pulse.code, 
         MY_PULSE_CODE );

  return 0;
}
</pre>


<p class="p">
Here's the server side that delivers the pulse defined by the <span class="keyword dtype">struct sigevent</span>:
</p>


<pre class="pre codeblock">
/* server.c */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/neutrino.h&gt;
#include &lt;sys/iomsg.h&gt;
#include &lt;sys/iofunc.h&gt;
#include &lt;sys/dispatch.h&gt;

#include "my_hdr.h"

int main(int argc, char **argv) {
  int             rcvid;
  union {
      struct my_msg   mine;
      struct _pulse   pulse;
  }           msg;
  name_attach_t  *attach;

  /* Attach the name the client will use to find us. */
  /* Our channel will be in the attach structure */
  if ((attach = name_attach(NULL, MY_SERV, 0)) == NULL) {
     printf("server:failed to attach name, errno %d\n", errno);
     exit(1);
  }

  /* Wait for the message from the client. */
  for( ;; ) {
     rcvid = MsgReceive(attach-&gt;chid, &amp;msg, sizeof(msg), NULL);
     switch(msg.mine.type) {
        case _PULSE_CODE_DISCONNECT:
           ConnectDetach(msg.pulse.scoid);
           break;
        case _IO_CONNECT:   
           MsgReply(rcvid, 0, NULL, 0);
           break;
        case MSG_GIVE_PULSE:    
           /* Wait until it is time to notify the client */
           sleep(2);

           /*
            * Deliver notification to client that client
            * requested
            */
           MsgDeliverEvent(rcvid, &amp;msg.mine.event);
           printf("server:delivered event\n");
           return 0;
        default:    
           printf("server: unexpected message %d\n", msg.mine.type);
           return 0;
     }
  }

  return 0;
}
</pre>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2232238e1011">Safety:</th>
<th class="entry" valign="top" id="d2232238e1013">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Signal handler</td>
<td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Thread</td>
<td class="entry" valign="top" headers="d2232238e1011 d2232238e1013 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>



<div class="section"><h2 class="title sectiontitle">Caveats:</h2>


<p class="p">
In the case of a pulse event, if the server faults on delivery, 
the pulse is either lost or an error is returned.
</p>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" title="Message Passing (Getting Started with QNX Neutrino)">Message Passing (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Events.html" title="Events (System Architecture)">Events (System Architecture)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceive.html" title="Wait for a message or pulse on a channel">MsgReceive(), MsgReceive_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" title="Wait for a message or pulse on a channel">MsgReceivev(), MsgReceivev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgregisterevent.html" title="Register a secure event">MsgRegisterEvent(), MsgRegisterEvent_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsend.html" title="Send a message to a channel">MsgSend(), MsgSend_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendpulse.html" title="Send a pulse to a process">MsgSendPulse(), MsgSendPulse_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendpulseptr.html" title="Send a pulse (containing a pointer) to a process">MsgSendPulsePtr(), MsgSendPulsePtr_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsendv.html" title="Send a message to a channel">MsgSendv(), MsgSendv_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgunregisterevent.html" title="Unregister a secure event">MsgUnregisterEvent(), MsgUnregisterEvent_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgverifyevent.html" title="Check the validity of a receive ID and an event configuration">MsgVerifyEvent(), MsgVerifyEvent_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/sigevent.html" title="Structure that describes an event">sigevent</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/signalwaitinfo.html" title="Select a pending signal">SignalWaitinfo(), SignalWaitinfo_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/signalwaitinfomask.html" title="Block a set of signals and then select a pending signal">SignalWaitinfoMask(), SignalWaitinfoMask_r()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>