
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="fork()" /><meta name="abstract" content="Create a new process" /><meta name="description" content="Create a new process" /><meta name="indexterms" content="fork()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/errno.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execl.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execle.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execlp.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execlpe.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execve.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execvp.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execvpe.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_destroy.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_init.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_lock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_trylock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_unlock.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/posix_spawn.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_atfork.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawn.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnl.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnle.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnlp.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnlpe.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnp.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnve.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnvp.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnvpe.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/w/wait.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="fork" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>fork()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="fork">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F">F</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">F</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">fork()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Create a new process</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork( void );
</pre>


<p class="p">
This function is declared in <span class="ph filepath">&lt;process.h&gt;</span>, which <span class="ph filepath">&lt;unistd.h&gt;</span>
includes.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<div class="p">



The <span class="keyword apiname">fork()</span>  function creates a new process.
The new process (child process) is an exact copy of the
calling process (parent process), except for the following:

<ul class="ul">
<li class="li">The child process has a unique process ID.</li>


<li class="li">The child process has a different parent process ID (which is
    the process ID of the calling process).
</li>


<li class="li">The child process has its own copy of the parent's file
    descriptors.  Each of the child's file descriptors refers to
    the same open file description with the corresponding file
    descriptor of the parent.
</li>


<li class="li">The child process has its own copy of the parent's open directory streams.</li>


<li class="li">The child process's values of <var class="keyword varname">tms_utime</var>, <var class="keyword varname">tms_stime</var>,
    <var class="keyword varname">tms_cutime</var>, and <var class="keyword varname">tms_cstime</var> are set to zero.
</li>


<li class="li">The child process has a single thread, regardless of the number that the parent has.</li>


<li class="li">File locks previously set by the parent aren't inherited by the child.</li>


<li class="li">The child process doesn't inherit any timers, <span class="keyword">QNX Neutrino</span>
  message-passing objects, side-channel connection IDs (coids), or channels (chids).</li>


<li class="li">(QNX Neutrino 7.1 or later) The child process doesn't inherit I/O privileges.
  
  
  
</li>


<li class="li">The set of signals pending for the child process is initialized to the empty set.</li>


<li class="li">No memory locks set by the parent process are inherited by the child. For more information, see
    <span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/proc_Locking_memory.html">Locking memory</a>&#148;</span>
    in the Process Manager chapter of the <cite class="cite">System Architecture</cite> guide.
</li>


<li class="li">No event notification requests, such as those requested with <span class="keyword apiname">ionotify()</span>, <span class="keyword apiname">mq_notify()</span>, 
    <span class="keyword apiname">procmgr_event_notify()</span>, <span class="keyword apiname">procmgr_value_notify()</span>, or <span class="keyword apiname">SyncMutexEvent()</span>, 
    are inherited by the child.
</li>

    
<li class="li">No interrupt handlers or events attached to interrupt sources through <span class="keyword apiname">InterruptAttach()</span>,
    <span class="keyword apiname">InterruptAttachArray()</span>, and <span class="keyword apiname">InterruptAttachEvent()</span> are inherited by the child.
</li>


</ul>

</div>


<div class="p">
Note that:
<ul class="ul">
<li class="li">A named semaphore
  (<a class="xref" href="../s/sem_open.html" title="Create or access a named semaphore"><span class="keyword apiname">sem_open()</span></a>)
  increments and decrements the same count in the parent and child,
  but an unnamed semaphore
  (<a class="xref" href="../s/sem_init.html" title="Initialize an unnamed semaphore"><span class="keyword apiname">sem_init()</span></a>)
  increments and decrements a different count (with the same initial value)
  in the two processes, unless that semaphore is in a shared memory object.
</li>


<li class="li">The child inherits any message queue descriptors from the parent, whether you're using the traditional
  (<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mqueue.html"><span class="keyword cmdname">mqueue</span></a>)
  or alternative
  (<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/m/mq.html"><span class="keyword cmdname">mq</span></a>)
  implementation of message queues.
</li>


<li class="li">The child inherits any memory mappings that were created in the parent, except for those that
  (in QNX Neutrino 7.1 or later) have the <span class="keyword const">MAP_NOINHERIT</span> flag set (see
  <a class="xref" href="../m/mmap.html" title="Map a memory region into a process's address space"><span class="keyword apiname">mmap()</span></a>).
  

  <p class="p">
  <span class="keyword const">MAP_PRIVATE</span> mappings inherited from the parent are also <span class="keyword const">MAP_PRIVATE</span> mappings
  in the child, and any modifications to the data in these mappings made by the parent prior to calling
  <span class="keyword apiname">fork()</span> are visible to the child.
  Any modifications to the data in <span class="keyword const">MAP_PRIVATE</span> mappings made by the parent or child after
  a <span class="keyword apiname">fork()</span> are visible only to the parent or child, respectively.
  </p>

</li>


<li class="li">The parent's ability configuration (see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>)
  is copied to the child verbatim,
  regardless of the <span class="keyword const">PROCMGR_AOP_INHERIT_NO</span> status of each of
  the abilities.
</li>


<li class="li">If the parent is a resource manager, then the child can't be a resource manager until after an <span class="keyword apiname">exec()</span>.
   
   
</li>


<li class="li">If the parent has used any of the <span class="keyword apiname">aio_*()</span> functions, then the child can't use any of the <span class="keyword apiname">aio_*()</span>
  functions until after an <span class="keyword apiname">exec()</span>.</li>


<li class="li">If the child will link a library at load time or at run time (i.e., with <span class="keyword apiname">dlopen()</span>), the child must be given the 
  <span class="keyword const">PROCMGR_AID_PROT_EXEC</span> and <span class="keyword const">PROCMGR_AID_MAP_FIXED</span> abilities. For more information, see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.</li>

 
</ul>

</div>


<p class="p">
In order to successfully call this function, your process must have the
<span class="keyword const">PROCMGR_AID_FORK</span> ability enabled.
For more information, see
<a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.

</p>


<p class="p">
You can use
<a class="xref" href="../p/pthread_atfork.html" title="Register fork handlers"><span class="keyword apiname">pthread_atfork()</span></a>
to register fork handler functions to be called before or after the fork occurs.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
<ul class="ul">
<li class="li">
POSIX requires that the child process use only functions that are async-signal-safe
until it calls one of the <span class="keyword apiname">exec*()</span> functions.
If your program uses mutexes, you might need to use a forksafe mutex or
register a <span class="keyword apiname">pthread_atfork()</span> handler
that locks all the mutexes before you fork.
</li>


<li class="li">A thread must not hold a <span class="keyword dtype">forksafe_mutex_t</span> when it invokes <span class="keyword apiname">fork()</span>, or else
  a deadlock will occur.
  The same is true of a <span class="keyword dtype">pthread_mutex_t</span> that's protected by an at-fork handler.
</li>


</ul>


<p class="p">
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs_Multithreaded_fork.html">Using <span class="keyword apiname">fork()</span> in a multithreaded process</a>&#148;</span>
in the <span class="q">&#147;Processes and Threads&#148;</span> chapter of <cite class="cite">Getting Started with <span class="keyword">QNX Neutrino</span></cite>.
</p>

</div>

</div>



<div class="section"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
A value of zero to the child process, and the process ID of the child process to the parent process.
Both processes continue to execute from the <span class="keyword apiname">fork()</span> function. 
If an error occurs, <span class="keyword apiname">fork()</span> returns -1 to the parent and sets
<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">


<dt class="dt dlterm"><span class="keyword const">EAGAIN</span></dt>

<dd class="dd">Insufficient resources are available to create the child process.
  For example, you might have exceeded the maximum number of processes
  permitted; see the <span class="keyword const">RLIMIT_NPROC</span> resource for
  <a class="xref" href="../g/getrlimit.html" title="Get the limit on a system resource"><span class="keyword apiname">getrlimit()</span></a>.
</dd>




<dt class="dt dlterm"><span class="keyword const">EBADF</span></dt>

<dd class="dd">A problem occurred when <span class="keyword apiname">fork()</span> was duplicating a file descriptor.
  For example, another thread might have opened or closed a file descriptor while the
  <span class="keyword apiname">fork()</span> was occurring.
  You can add synchronization around the operations that involve file descriptors,
  or try calling <span class="keyword apiname">fork()</span> again.
</dd>




<dt class="dt dlterm"><span class="keyword const">ENOMEM</span></dt>

<dd class="dd">The process requires more memory than the system is able to supply.</dd>




<dt class="dt dlterm"><span class="keyword const">ENOSYS</span></dt>

<dd class="dd">The <span class="keyword apiname">fork()</span> function isn't implemented for this memory protection model.</dd>




<dt class="dt dlterm"><span class="keyword const">EPERM</span></dt>

<dd class="dd">One of the following occurred:

  <ul class="ul">
  <li class="li">The calling process doesn't have the required permission; see
  <a class="xref" href="../p/procmgr_ability.html" title="Control a process's ability to perform certain operations"><span class="keyword apiname">procmgr_ability()</span></a>.
  </li>


  <li class="li">(QNX Neutrino 7.0.1 or later) The calling process's priority is above the permitted range.</li>


  </ul>

</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Examples:</h2>


<p class="p">
This program demonstrates forking.
You run it like this:
</p>


<pre class="pre codeblock">
fork_example <var class="keyword varname">program</var> [<var class="keyword varname">arguments</var>]
</pre>


<p class="p">
The child runs <var class="keyword varname">program</var> (passing it the <var class="keyword varname">arguments</var>, if any),
and the parent waits for the child to exit.
</p>


<pre class="pre codeblock">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main( int argc, char **argv )
{
    pid_t pid;
    pid_t wpid;
    int   status;

    if (argc == 1) {
        printf ("Usage: %s &lt;program&gt; [&lt;arguments&gt;]\n", argv[0]);
        return EXIT_FAILURE;
    }

    if( ( pid = fork() ) == -1 ) {
        perror( "fork" );
        return EXIT_FAILURE;
    }

    if( pid == 0 ) {
        printf ("Child: My pid is %d.\n", getpid() );

        /* Use exec to become the specified program. */
        execvp( argv[1], argv+1 );

        /* This can happen only if execvp() fails; print a message, and then exit. */
        perror( argv[1] );
        return EXIT_FAILURE;

    } else {
        printf ("Parent: My pid is %d.\n", getpid() );

        /* Wait for the child to finish. */
        do {
            wpid = waitpid( pid, &amp;status, 0 );
        } while( WIFEXITED( status ) == 0 );

        printf ("Parent: Child %d has exited with status %d; we're done!\n",
                wpid, WEXITSTATUS( status ));
        return WEXITSTATUS( status );
    }
}
</pre>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">POSIX 1003.1</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d1451940e579">Safety:</th>
<th class="entry" valign="top" id="d1451940e581">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Cancellation point</td>
<td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Signal handler</td>
<td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Thread</td>
<td class="entry" valign="top" headers="d1451940e579 d1451940e581 ">Read the Caveats</td>
</tr>

</tbody>

</table>
</div>

</div>


<div class="section"><h2 class="title sectiontitle">Caveats</h2>


<p class="p">
It's possible to call <span class="keyword apiname">fork()</span> from a multithreaded process, but it can be very difficult
to do so safely, so we recommend that you call it only from single-threaded processes.
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs_Multithreaded_fork.html">Using <span class="keyword apiname">fork()</span> in a multithreaded process</a>&#148;</span>
in the <span class="q">&#147;Processes and Threads&#148;</span> chapter of <cite class="cite">Getting Started with <span class="keyword">QNX Neutrino</span></cite>.
</p>


</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_procs.html" title="Processes and Threads (Getting Started with QNX Neutrino)">Processes and Threads (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/errno.html" title="Thread-local error variable">errno</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execl.html" title="Execute a file">execl()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execle.html" title="Execute a file">execle()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execlp.html" title="Execute a file">execlp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execlpe.html" title="Execute a file">execlpe()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execv.html" title="Execute a file">execv()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execve.html" title="Execute a file">execve()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execvp.html" title="Execute a file">execvp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/e/execvpe.html" title="Execute a file">execvpe()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_destroy.html" title="Destroy a forksafe mutex">forksafe_mutex_destroy()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_init.html" title="Initialize a forksafe mutex">forksafe_mutex_init()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_lock.html" title="Lock a forksafe mutex">forksafe_mutex_lock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_trylock.html" title="Attempt to lock a forksafe mutex">forksafe_mutex_trylock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/f/forksafe_mutex_unlock.html" title="Unlock a forksafe mutex">forksafe_mutex_unlock()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/posix_spawn.html" title="Spawn a process">posix_spawn(), posix_spawnp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/procmgr_ability.html" title="Control a process's ability to perform certain operations">procmgr_ability()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/pthread_atfork.html" title="Register fork handlers">pthread_atfork()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawn.html" title="Create and execute a new child process">spawn()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnl.html" title="Spawn a child process, given a list of arguments">spawnl()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnle.html" title="Spawn a child process, given a list of arguments and an environment">spawnle()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnlp.html" title="Spawn a child process, given a list of arguments and a relative path">spawnlp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnlpe.html" title="Spawn a child process, given a list of arguments, an environment, and a relative path">spawnlpe()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnp.html" title="Create and execute a new child process, given a relative path">spawnp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnv.html" title="Spawn a child process, given a vector of arguments">spawnv()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnve.html" title="Spawn a child process, given a vector of arguments and an environment">spawnve()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnvp.html" title="Spawn a child process, given a vector of arguments and a relative path">spawnvp()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/s/spawnvpe.html" title="Spawn a child process, given a vector of arguments, an environment, and a relative path">spawnvpe()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/w/wait.html" title="Wait for the status of a terminated child process">wait()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-f.html" title="F"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">F</span></a></span>  </div>
</body>
</html>