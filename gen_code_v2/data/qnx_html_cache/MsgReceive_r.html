
<!DOCTYPE html
  PUBLIC "" "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />        
      <meta name="copyright" content="(C) Copyright 2005" /><meta name="DC.rights.owner" content="(C) Copyright 2005" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="MsgReceive(), MsgReceive_r()" /><meta name="abstract" content="Wait for a message or pulse on a channel" /><meta name="description" content="Wait for a message or pulse on a channel" /><meta name="indexterms" content="MsgReceive(), MsgReceive_r()" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/c/channelcreate.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/_msg_info.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgerror.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msginfo.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgread.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreadv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivepulse.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivepulsev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreply.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreplyv.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsend.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwrite.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwritev.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/p/_pulse.html" /><meta name="DC.Relation" scheme="URI" content="../../../com.qnx.doc.neutrino.lib_ref/topic/t/timertimeout.html" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="msgreceive" /><meta name="DC.Language" content="en-us" /><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>MsgReceive(), MsgReceive_r()</title><link rel="canonical" type="html" href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/" /><!--  Generated with Oxygen version 18.1, build number 2017020917.  --><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="../../../oxygen-webhelp/resources/skins/skin.css" /><script type="text/javascript"><!--
            
            var prefix = "../../../index.html";
            
            --></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-1.11.3.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="../../../oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="../../../oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script><script type="text/javascript"> var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-27400275-1']); _gaq.push(['_setDomainName', 'www.qnx.com']);_gaq.push(['_setAllowLinker', true]);_gaq.push(['_trackPageview']);(function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="msgreceive">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td style="width:75%;"><span class="topic_breadcrumb_links"><span class="topic_breadcrumb_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M">M</a></span></span></td><td><span id="topic_navigation_links" class="navheader">
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </span></td></tr></tbody></table>


<h1 class="title topictitle1"><span class="keyword apiname">MsgReceive()</span>, <span class="keyword apiname">MsgReceive_r()</span></h1>
<table width="100%"><tbody><tr><td align="left"><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">QNX SDP</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">7.1</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">C Library Reference</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">API</button><button style="margin:3px 5px; background-color:default; border:default; pointer-events: none; font-size:0.9em;">Developer</button></td><td align="right"><span style="margin:0px 5px; font-size:0.9em;">Updated: October 28, 2024</span></td></tr></tbody></table>


<div class="body refbody"><p class="shortdesc"><em class="ph i">Wait for a message or pulse on a channel</em></p>


<div class="section refsyn"><h2 class="title sectiontitle">Synopsis:</h2>

<pre class="pre codeblock">
#include &lt;sys/neutrino.h&gt;

int MsgReceive( int <var class="keyword varname">chid</var>,
                void * <var class="keyword varname">msg</var>,
                size_t <var class="keyword varname">bytes</var>,
                struct _msg_info * <var class="keyword varname">info</var> );

int MsgReceive_r( int <var class="keyword varname">chid</var>,
                  void * <var class="keyword varname">msg</var>,
                  size_t <var class="keyword varname">bytes</var>,
                  struct _msg_info * <var class="keyword varname">info</var> );
</pre>

</div>



<div class="section"><h2 class="title sectiontitle">Arguments:</h2>


<dl class="dl">

<dt class="dt dlterm"><var class="keyword varname">chid</var></dt>

<dd class="dd">The ID of a channel that you established by calling
  <a class="xref" href="../c/channelcreate.html" title="Create a communications channel"><span class="keyword apiname">ChannelCreate()</span></a>,
  or -1 to dissociate the thread from the last channel it received on (see
  <span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Server_boost.html">Server boost</a>&#148;</span>
  in the Interprocess Communication chapter of the <cite class="cite">System Architecture</cite> guide).
</dd>




<dt class="dt dlterm"><var class="keyword varname">msg</var></dt>

<dd class="dd">A pointer to a buffer where the function can store the received data.</dd>




<dt class="dt dlterm"><var class="keyword varname">bytes</var></dt>

<dd class="dd">The size of the buffer.
  This number must not exceed <span class="keyword const">SSIZE_MAX</span>, or the function will behave unpredictably.
</dd>




<dt class="dt dlterm"><var class="keyword varname">info</var></dt>

<dd class="dd"><span class="keyword const">NULL</span>, or a pointer to a
  <a class="xref" href="_msg_info.html" title="Information about a message"><span class="keyword dtype">_msg_info</span></a>
  structure where the function can store additional information about the message.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Library:</h2>


<p class="p"><span class="ph filepath">libc</span></p>


<p class="p">
Use the <span class="keyword option">-l c</span> option to
<a class="xref" href="../../../com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><span class="keyword cmdname">qcc</span></a>
to link against this library.
This library is usually included automatically.
</p>

</div>



<div class="section"><h2 class="title sectiontitle">Description:</h2>


<p class="p">





The <span class="keyword apiname">MsgReceive()</span> and <span class="keyword apiname">MsgReceive_r()</span>
kernel calls wait for a message
or pulse to arrive on the channel identified by <var class="keyword varname">chid</var>, and
store the received data in the buffer pointed to by <var class="keyword varname">msg</var>.
</p>


<p class="p">
These functions are identical, except in the way they indicate errors; see the
<a class="xref" href="#msgreceive__Returns">Returns</a> section for details.
</p>


<p class="p">
The number of bytes transferred is the minimum of that specified
by both the sender and the receiver. The received data isn't allowed
to overflow the receive buffer area provided.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
The <var class="keyword varname">msg</var> buffer <em class="ph i">must</em> be big enough to contain a pulse.
If it isn't, the functions indicate an error of <span class="keyword const">EFAULT</span>.
</div>


<p class="p">
If a message is waiting on the channel when you call
<span class="keyword apiname">MsgReceive()</span>, the calling thread 
doesn't block, and the message is immediately copied. If a message isn't
waiting, the calling thread enters the RECEIVE-blocked state until a message arrives.
</p>


<p class="p">
If multiple messages are sent to a channel without a thread waiting to
receive them, the messages are queued in priority order.
</p>


<div class="note note"><span class="notetitle">Note:</span> 
The thread's effective priority might change when it receives a message.
For more information, see
<span class="q">&#147;<a class="xref" href="../../../com.qnx.doc.neutrino.sys_arch/topic/ipc_Priority_inheritance_messages.html">Priority inheritance and messages</a>&#148;</span>
in the Interprocess Communication (IPC) chapter of the <cite class="cite">System Architecture</cite> guide.
</div>


<p class="p">
If you pass a non-<span class="keyword const">NULL</span> pointer for <var class="keyword varname">info</var>, the
functions store additional information about the message and the thread
that sent it in the <span class="keyword dtype">_msg_info</span> structure that <var class="keyword varname">info</var> points to.
You can get this information later by calling
<a class="xref" href="msginfo.html" title="Get additional information about a message"><span class="keyword apiname">MsgInfo()</span></a>.
</p>


<p class="p">
On success, <span class="keyword apiname">MsgReceive()</span> and <span class="keyword apiname">MsgReceive_r()</span> return:
</p>


<dl class="dl">

<dt class="dt dlterm">&gt;0</dt>

<dd class="dd">A message was received; the returned value is a a <var class="keyword varname">rcvid</var> (receive identifier).
  You'll use the <var class="keyword varname">rcvid</var> with other <span class="keyword apiname">Msg*()</span> kernel calls to interact
  with and reply to the sending thread. 
  <span class="keyword apiname">MsgReceive()</span> changes the state of the sending thread to REPLY-blocked
  when the message is received.
  When you use <span class="keyword apiname">MsgReply*()</span> to reply to the received message, the sending
  thread is made ready again.
  The <var class="keyword varname">rcvid</var> encodes the sending thread's ID and a local connection ID.
  
  
</dd>




<dt class="dt dlterm">0</dt>

<dd class="dd">A pulse was received;
  <var class="keyword varname">msg</var> contains a pulse message of type
  <a class="xref" href="../p/_pulse.html" title="Structure that describes a pulse"><span class="keyword dtype">_pulse</span></a>.
  When a pulse is received, the kernel space allocated to hold it is immediately released.
  The <span class="keyword dtype">_msg_info</span> structure isn't updated.
</dd>



</dl>


<div class="note note"><span class="notetitle">Note:</span> 
Don't reply to a pulse.
</div>


<p class="p"><strong class="ph b">Blocking states</strong></p>




<dl class="dl">

<dt class="dt dlterm"><span class="keyword const">STATE_RECEIVE</span></dt>

<dd class="dd">There's no message waiting.</dd>



</dl>


<p class="p"><strong class="ph b">Native networking</strong></p>


<p class="p">
In networked message-passing transactions, the most
noticeable impact is on the server. The server receives the
client's message from the server's local <span class="ph filepath">lsm-qnet.so</span>.
Note that the receive ID that comes
back from <span class="keyword apiname">MsgReceive()</span> will have some
differences, but you don't need to worry about the format of the
receive IDâjust treat it as a <span class="q">&#147;magic cookie.&#148;</span>
</p>


<p class="p">
When the server unblocks from its <span class="keyword apiname">MsgReceive()</span>,
it may or may not have received as much of the message as it
would in the local case. This is because of the way that
message passing is definedâthe client and the server
agree on the size of the message transfer area (the transmit
parameters passed to <span class="keyword apiname">MsgSend()</span> on the client end)
and the size of the message receive area on the server's <span class="keyword apiname">MsgReceive()</span>.
</p>


<p class="p">
In a local message pass, the kernel
would ordinarily limit the size of the transfer to the
minimum of both sizes. But in the networked case, the
message is received by the client's <span class="ph filepath">lsm-qnet.so</span> into
its own private buffers and then sent via transport to the
remote <span class="ph filepath">lsm-qnet.so</span>. Since the size of the server's
receive data area can't be known in advance by the client's
<span class="ph filepath">lsm-qnet.so</span> when the message is sent, only a fixed
maximum size (currently 8 KB) message is transferred between
the client and the server.
</p>


<p class="p">
This means, for example, that if the client sends 1 Mbyte of
data and the server issues a <span class="keyword apiname">MsgReceive()</span> with a
1-Mbyte data area, then only the number of bytes determined by
a network manager would in fact be transferred. The number of
bytes transferred to the server is returned via the
last parameter to <span class="keyword apiname">MsgReceive()</span> or a call to
<span class="keyword apiname">MsgInfo()</span>, specifically the <var class="keyword varname">msglen</var> member of
struct <span class="keyword dtype">_msg_info</span>. The client doesn't notice this, 
because it's still blocked.
</p>


<p class="p">
You can use the following code to ensure that the desired number of bytes are received.
Note that this is handled for you automatically when you're using the resource manager library:
</p>


<pre class="pre codeblock">
rcvid = MsgReceive(chid, msg, nbytes, &amp;info);

/*
 Doing a network transaction, and not all
 the message was sent, so get the rest...
*/
if (rcvid &gt; 0 &amp;&amp; info.srcmsglen &gt; info.msglen &amp;&amp; info.msglen &lt; nbytes) {
   ssize_t n;

   if((n = MsgRead_r(rcvid, (char *) msg + info.msglen,
           nbytes - info.msglen, info.msglen)) &lt; 0) {
       MsgError(rcvid, (int) -n);
       continue;
   }
   info.msglen += n;
}
</pre>


</div>



<div class="section" id="msgreceive__Returns"><h2 class="title sectiontitle">Returns:</h2>


<p class="p">
On success, both functions return a positive <var class="keyword varname">rcvid</var>
if they received a message, or <span class="keyword const">EOK</span> if they received a pulse.
The only difference between <span class="keyword apiname">MsgReceive()</span> and <span class="keyword apiname">MsgReceive_r()</span>
is the way they indicate errors:

</p>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword apiname">MsgReceive()</span></dt>

<dd class="dd">If an error occurs, this function returns -1 and sets
<a class="xref" href="../e/errno.html" title="Thread-local error variable"><var class="keyword varname">errno</var></a>.
</dd>




<dt class="dt dlterm"><span class="keyword apiname">MsgReceive_r()</span></dt>

<dd class="dd">If an error occurs, this function may return the negative of any value from the Errors section.
This function does <strong class="ph b">NOT</strong> set <var class="keyword varname">errno</var>, even on success.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Errors:</h2>


<dl class="dl" compact="compact">

<dt class="dt dlterm"><span class="keyword const">EFAULT</span></dt>

<dd class="dd">A fault occurred when the kernel tried to access the buffers provided.
  Because the OS accesses the sender's buffers only when
  <span class="keyword apiname">MsgReceive()</span> is called, 
  a fault could occur <em class="ph i">in the sender</em> if the sender's buffers are invalid.
  If a fault occurs when accessing the sender buffers
  (only) they'll receive an <span class="keyword const">EFAULT</span> and <span class="keyword apiname">MsgReceive()</span> won't unblock.

  <p class="p">
  This error also occurs if the kernel tries to deliver a pulse to the server, but the
  size of the receive buffer is less than the size of a <span class="keyword dtype">struct _pulse</span>.
  The pulse is lost in this case.
  </p>


</dd>




<dt class="dt dlterm"><span class="keyword const">EINTR</span></dt>

<dd class="dd">The call was interrupted by a signal.</dd>




<dt class="dt dlterm"><span class="keyword const">ESRCH</span></dt>

<dd class="dd">The channel indicated by <var class="keyword varname">chid</var> doesn't exist.</dd>




<dt class="dt dlterm"><span class="keyword const">ETIMEDOUT</span></dt>

<dd class="dd">A kernel timeout unblocked the call.
  See <a class="xref" href="../t/timertimeout.html" title="Set a timeout on a blocking state"><span class="keyword apiname">TimerTimeout()</span></a>.
</dd>



</dl>


</div>



<div class="section"><h2 class="title sectiontitle">Classification:</h2>

<p class="p"><a class="xref" href="../summary.html#summary__CLASSIFICATION">QNX Neutrino</a></p>



<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all">
<thead class="thead" align="left">
<tr><th class="entry" valign="top" id="d2239999e592">Safety:</th>
<th class="entry" valign="top" id="d2239999e594">Â </th>
</tr>

</thead>

<tbody class="tbody">
<tr><td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Cancellation point</td>
<td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Interrupt handler</td>
<td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">No</td>
</tr>

<tr><td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Signal handler</td>
<td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Yes</td>
</tr>

<tr><td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Thread</td>
<td class="entry" valign="top" headers="d2239999e592 d2239999e594 ">Yes</td>
</tr>

</tbody>

</table>
</div>

</div>



<div class="section"><h2 class="title sectiontitle">Caveats:</h2>


<p class="p">
The maximum size for a one-part message depends on the architecture:
</p>


<ul class="ul">
<li class="li">For 32-bit architectures, it's <span class="keyword const">SSIZE_MAX</span> (i.e., 2<sup class="ph sup">31</sup> â 1) bytes.</li>


<li class="li">For 64-bit architectures, the API allows up to <span class="keyword const">SSIZE_MAX</span> (i.e., 2<sup class="ph sup">63</sup> â 1) bytes,
  but the virtual address space limits the size to 2<sup class="ph sup">39</sup> bytes.
</li>


</ul>

</div>


</div>


<div class="related-links"><div class="relinfo relconcepts"><strong>Related concepts</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.getting_started/topic/s1_msg.html" title="Message Passing (Getting Started with QNX Neutrino)">Message Passing (Getting Started with <span class="keyword">QNX Neutrino</span>)</a></div>
</div>
<div class="relinfo relref"><strong>Related reference</strong><br />
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/c/channelcreate.html" title="Create a communications channel">ChannelCreate(), ChannelCreate_r(), ChannelCreatePulsePool()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/_msg_info.html" title="Information about a message">_msg_info</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgerror.html" title="Unblock a client and set its error code">MsgError(), MsgError_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msginfo.html" title="Get additional information about a message">MsgInfo(), MsgInfo_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgread.html" title="Read data from a message">MsgRead(), MsgRead_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreadv.html" title="Read data from a message">MsgReadv(), MsgReadv_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivepulse.html" title="Receive a pulse on a channel">MsgReceivePulse(), MsgReceivePulse_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivepulsev.html" title="Receive a pulse on a channel">MsgReceivePulsev(), MsgReceivePulsev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreceivev.html" title="Wait for a message or pulse on a channel">MsgReceivev(), MsgReceivev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreply.html" title="Reply with a message">MsgReply(), MsgReply_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgreplyv.html" title="Reply with a message">MsgReplyv(), MsgReplyv_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgsend.html" title="Send a message to a channel">MsgSend(), MsgSend_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwrite.html" title="Write a reply">MsgWrite(), MsgWrite_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/m/msgwritev.html" title="Write a reply">MsgWritev(), MsgWritev_r()</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/p/_pulse.html" title="Structure that describes a pulse">_pulse</a></div>
<div class="related_link"><a class="navheader_parent_path" href="../../../com.qnx.doc.neutrino.lib_ref/topic/t/timertimeout.html" title="Set a timeout on a blocking state">TimerTimeout(), TimerTimeout_r()</a></div>
</div>
</div><div class="navfooter"><!---->
<span class="navparent"><a class="link" href="../../../com.qnx.doc.neutrino.lib_ref/topic/lib-m.html" title="M"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">M</span></a></span>  </div>
</body>
</html>